{
    "docs": [
        {
            "location": "/", 
            "text": "About\n\n\nThis is the official repository of the Open Web Interface for Node.js (OWIN-JS) Specification. \n\n\nOWIN-JS defines a standard framework for REST servers for io.js and Node.js.\n\nIt is a port of the \nOWIN\n specification, but expands the REST philosophy to web servers, application clients, desktop/mobile apps, etc. \n\n\nOWIN-JS is targeted for multiple transport providers including HTTP and COAP servers, and can be a drop-in replacement for existing frameworks such as Connect/Express on Node.js.   It defines a standard way that application/device logic can rely on REST server capabilities without being tied to any one transport (http, express, koa, node-coap, etc.) \n\n\nThe goal of OWIN-D is to decouple transport and application logic and, by being a free open-source standard (under Creative Commons), stimulate the open source ecosystem of web server development tools, without ties to any one framework such as Connect, Express, Koa.js, IIS, node-coap etc while at the same time being used in commercial applications without restriction.\n\n\nReference Implementations\n\n\nOWIN-JS is the specification and contains no implementation source code.   However, reference implementations with fully functioning application and server stacks are only one click away:\n\n\n\n\n\n\nlimerun\n - The reference OWIN-JS implementation for Javascript;  includes a broad ecosystem of HTTP, CoAP, and desktop/mobile embedded server and middleware components (routers, view engines, static asset server, etc.)\n\n\n\n\n\n\nnodekit.io\n - OWIN-JS implementations for OS/X and iOS desktop applications;  contains an embedded lightweight fork of Node.js to run anywhere \n\n\n\n\n\n\nSpecifications\n\n\nOWIN-JS Specification\n  (this repository)\n\n\nOWIN-D Specification\n (Extends OWIN-JS for Networked Devices and Internet of Things) \n\n\nOriginal OWIN Specification for reference\n (for .NET only)\n\n\nLicense\n\n\nCreative Commons Attribution 3.0 Unported License", 
            "title": "Home"
        }, 
        {
            "location": "/#about", 
            "text": "This is the official repository of the Open Web Interface for Node.js (OWIN-JS) Specification.   OWIN-JS defines a standard framework for REST servers for io.js and Node.js. \nIt is a port of the  OWIN  specification, but expands the REST philosophy to web servers, application clients, desktop/mobile apps, etc.   OWIN-JS is targeted for multiple transport providers including HTTP and COAP servers, and can be a drop-in replacement for existing frameworks such as Connect/Express on Node.js.   It defines a standard way that application/device logic can rely on REST server capabilities without being tied to any one transport (http, express, koa, node-coap, etc.)   The goal of OWIN-D is to decouple transport and application logic and, by being a free open-source standard (under Creative Commons), stimulate the open source ecosystem of web server development tools, without ties to any one framework such as Connect, Express, Koa.js, IIS, node-coap etc while at the same time being used in commercial applications without restriction.", 
            "title": "About"
        }, 
        {
            "location": "/#reference-implementations", 
            "text": "OWIN-JS is the specification and contains no implementation source code.   However, reference implementations with fully functioning application and server stacks are only one click away:    limerun  - The reference OWIN-JS implementation for Javascript;  includes a broad ecosystem of HTTP, CoAP, and desktop/mobile embedded server and middleware components (routers, view engines, static asset server, etc.)    nodekit.io  - OWIN-JS implementations for OS/X and iOS desktop applications;  contains an embedded lightweight fork of Node.js to run anywhere", 
            "title": "Reference Implementations"
        }, 
        {
            "location": "/#specifications", 
            "text": "OWIN-JS Specification   (this repository)  OWIN-D Specification  (Extends OWIN-JS for Networked Devices and Internet of Things)   Original OWIN Specification for reference  (for .NET only)", 
            "title": "Specifications"
        }, 
        {
            "location": "/#license", 
            "text": "Creative Commons Attribution 3.0 Unported License", 
            "title": "License"
        }, 
        {
            "location": "/Specification/", 
            "text": "Specification v1.2.0 RELEASE\n\n\n\n\nTitle: Open Web Interface for Node.js (OWIN-JS)\n\n\nAuthor : OWIN-JS working group\n\n\nPorted from: \nOWIN\n (authored by OWIN working group)\n\n\nCopyright : OWIN-JS contributors, OWIN Contributors\n\n\nLicense : \nCreative Commons Attribution 3.0 Unported License\n\n\n\n\nContents\n\n\n1. \nOverview\n\n\n2. \nDefinitions\n\n\n3. \nRequest Execution\n\n\n3.1. \nApplication Delegate\n\n\n3.2. \nEnvironment\n\n\n3.3. \nHeaders\n\n\n3.4. \nRequest Body\n\n\n3.5. \nResponse Body\n\n\n3.6. \nRequest Lifetime\n\n\n4. \nApplication Startup\n\n\n5. \nURI Reconstruction\n\n\n5.1. \nURI Scheme\n\n\n5.2. \nHostname\n\n\n5.3. \nPaths\n\n\n5.4. \nURI Reconstruction Algorithm\n\n\n5.5. \nPercent-encoding\n\n\n6. \nError Handling\n\n\n6.1. \nApplication Errors\n\n\n6.2. \nServer Errors\n\n\n7. \nVersioning\n\n\n8. \nExtensions\n\n\n9. \nReal World Usage\n\n\n1. Overview\n\n\nThis document defines the Open Web Interface for Node.js (OWIN-JS), a standard framework for REST servers for io.js, Node.js and backwards compatible with .NET.  \n\n\nOWIN-JS is targeted for multiple transport providers including HTTP, COAP and MQTT servers, and can be a drop-in replacement for existing frameworks such as Connect/Express on Node.js.   It defines a standard way that application/device logic can rely on REST server capabilities without being tied to any one transport (http, express, koa, node-coap, mosca, etc.) \n\n\nOWIN-JS is a port of the \nOWIN\n specification, but expands the REST philosophy to web servers, application clients, desktop/mobile apps, etc.  \n\n\nSee also \nOWIN-D\n for an extension of this OWIN-JS specification that specifically targets devices and accessories in the Internet of Things, and see example applications such as \nnodekit.io\n that show how OWIN-JS can enable a standalone desktop app.\n\n\nOWIN-JS is defined in terms of a delegate structure. There is no assembly. Implementing either the host or application side the OWIN-JS spec does not introduce a dependency to a project.\n\n\nIn this document, the Node.js \nfunction\n and C# \nAction\n/\nFunc\n syntax is used to notate some delegate structures.   However, the delegate structure could be equivalently represented with other native functions, CLR interfaces, or named delegates. This is by design; when implementing OWIN-JS, choose a delegate representation that works for you and your stack.\n\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in \nRFC 2119\n.\n\n\n2. Definitions\n\n\nThis document refers to the following software actors:\n\n\n\n\n\n\nServer \u2013 The REST server (typically HTTP, COAP or MQTT) that directly communicates with the client and then uses OWIN-JS semantics to process requests. Servers may require an adapter layer that converts to OWIN-JS semantics.\n\n\n\n\n\n\nFramework \u2013 A self-contained component based on OWIN-JS exposing its own object model or API that applications may use to facilitate request processing. Frameworks may require an adapter layer that converts from OWIN-JS semantics.\n\n\n\n\n\n\nApplication \u2013 A specific application or device logic, possibly built on top of a Web Framework, which is run using OWIN-JS compatible Servers.\n\n\n\n\n\n\nMiddleware \u2013 Pass through components that form a pipeline between a server and application to inspect, route, or modify request and response messages for a specific purpose.\n\n\n\n\n\n\nHost \u2013 The process an application and server execute inside of, primarily responsible for application startup. Some Servers are also Hosts.\n\n\n\n\n\n\n3. Request Execution\n\n\nBroadly speaking, a server invokes an application (providing as arguments an environment dictionary with request and response headers and bodies); an application either populates a response or indicates an error.\n\n\n3.1. Application Delegate\n\n\nThe primary interface in OWIN-JS is called the \napplication delegate\n or \nAppFunc\n. An application delegate takes the Dictionary environment and returns a Promise or a Task when it has finished processing.\n\n\nNode.js AppFunc (returns a Promise/A)\n\n\nvar myAppFuncPromise = function() {...};\n\n\n\nwhere \nthis\n is set to the Dictionary environment and \nmyAppFuncPromise\n is a Promise/A promise that can be chained with     \nmyAppFuncPromise.then(... , ... )\n etc.\n\n\n.NET\n\n\nusing AppFunc = Func\n\n    IDictionary\nstring, object\n, // Environment\n    Task\n; // Done\n\n\n\n\n\nThe application MUST eventually complete the returned \ntask/promise\n, or throw an exception.\n\n\n\n\n3.2. Environment\n\n\nThe Environment object stores information about the request, the response, and any relevant server state.  The server is responsible for providing body streams and header collections for both the request and response in the initial call. The application then populates the appropriate fields with response data, writes the response body, and returns when done.\n\n\n\n\n\n\nThe environment object MUST be non-null, mutable and MUST contain the keys listed as required in the tables below (listed under \nOWIN-JS Key Name\n column title)\n\n\n\n\n\n\nKeys MUST be compared using StringComparer.Ordinal.\n\n\n\n\n\n\nThe values associated with the keys MUST be non-null, unless otherwise specified.\n\n\n\n\n\n\nThe implementation MAY provide aliases that are convenient to access in the selected programming language chosen (i.e., ECMAScript/JavaScript, C#) to avoid \ncontext[\"owin.Key\"]\n type accessors in favor of \nthis.owinKey\n (for intellitype, strong typing, capitalization conventions, separation of \nrequest\n and \nresponse\n objects, etc.).  \n\n\n\n\n\n\nIf a server does not implement alias names, middleware such as \nOWIN-JS/owin-js\n MAY be used to add such alias names.  \n\n\n\n\n\n\nAlias names used by the OwinJS/owinjs reference implementation and indicated in the table below, are RECOMMENDED as the preferred naming convention.  Additional aliases or helper functions MAY be provided in addition to these.\n\n\n\n\n\n\nWhere provided, alias property getters and setters MUST ensure continued synchronization with the original environment dictionary property (i.e., these are reference \nmirrors\n not value \ncopies\n).  \n\n\n\n\n\n\nPeriods in \nOWIN-JS Key Names\n are considered part of the single string and therefore require quotes for access in most C-style languages (e.g., \nvar body = context[\"owin.RequestBody\"];\n).\n\n\n\n\n\n\nPeriods in \nalias names\n indicate separate layers in the object hierarchy (e.g., \ncontext\n object contains a \nrequest\n alias property which contains a \nbody\n property, a \npath\n string, a \npathBase\n string etc.).  All aliases key names SHOULD be in \ncamelCase\n capitalization.   (e.g., \nvar body = this.request.body;\n)\n\n\n\n\n\n\nImplementations of OWIN-JS servers and/or middleware harnesses MAY omit the context variable as an explicit parameter for applications and middleware functions and instead set the base language's context object (e.g., \nthis\n in ECMAScript/Javascript).\n\n\n\n\n\n\nThe environment dictionary SHOULD allow additional prototype methods to be added to its prototype object, to facilitate alias implementations that are defined once per server instance, not once per request\n\n\n\n\n\n\n3.2.1 Request Data\n\n\n\n\n\n\n\n\nRequired\n\n\nOWIN-JS Key Name\n\n\nRecommended Aliases\n\n\nValue Description\n\n\n\n\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestBody\"\n\n\nthis.request.body\nthis.request\n\n\nA Stream/BufferList with the request payload, if any Stream.  Null MAY be used as a placeholder if there is no request body. See \nRequest Body\n.\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestHeaders\"\n\n\nthis.request.headers\n\n\nA Dictionary of request headers/options. See \nHeaders\n.\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestMethod\"\n\n\nthis.request.method\n\n\nA \nstring\n containing the request method of the request (e.g., \n\"GET\"\n, \n\"PUT\"\n, \n\"DELETE\"\n, \n\"POST\"\n, \n\"CONNECT\"\n, \n\"SUBSCRIBE\"\n).\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestPath\"\n\n\nthis.request.path\n\n\nA \nstring\n containing the request path. The path MUST be relative to the \"root\" of the application delegate; see \nPaths\n.\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestPathBase\"\n\n\nthis.request.pathBase\n\n\nA \nstring\n containing the portion of the request path corresponding to the \"root\" of the application delegate; see \nPaths\n.\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestProtocol\"\n\n\nthis.request.protocol\n\n\nA \nstring\n containing the protocol name and version (e.g. \n\"COAP/1.0\"\n, \n\"HTTP/1.1\"\n, or \n\"MQTT/3.1.1\"\n).\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestQueryString\"\n\n\nthis.request.queryString\n\n\nA \nstring\n containing the query string component of the request URI, without the leading \u201c?\u201d (e.g., \n\"foo=bar\namp;baz=quux\"\n). The value may be an empty string.\n\n\n\n\n\n\nYes\n\n\n\"owin.RequestScheme\"\n\n\nthis.request.scheme\n\n\nA \nstring\n containing the URI scheme used for the request (e.g., \n\"http\"\n, \n\"coap\"\n, \n\"https\"\n, \n\"mqtt\"\n); see \nURI Scheme\n.\n\n\n\n\n\n\n\n\n3.2.2 Response Data\n\n\n\n\n\n\n\n\nRequired\n\n\nOWIN-JS Key Name\n\n\nRecommended Aliases\n\n\nValue Description\n\n\n\n\n\n\n\n\n\n\nYes\n\n\n\"owin.ResponseBody\"\n\n\nthis.response.body\nthis.response\n\n\nA Stream/BufferList used to write/append the response payload, if any. See \nResponse Body\n.\n\n\n\n\n\n\nYes\n\n\n\"owin.ResponseHeaders\"\n\n\nthis.response.headers\n\n\nA Dictionary of response headers/options. See \nHeaders\n.\n\n\n\n\n\n\nYes\n\n\n\"owin.ResponseStatusCode\"\n\n\nthis.response.statusCode\n\n\nAn optional \ninteger\n containing the REST response status code as defined by the transport protocol (COAP, HTTP or MQTT).\n\n\n\n\n\n\nYes\n\n\n\"owin.ResponseReasonPhrase\"\n\n\nthis.response.reasonPhrase\n\n\nAn optional \nstring\n containing the reason phrase associated the given status code. If none is provided then the server SHOULD provide a default as described in \nRFC 2616\n section 6.1.1\n\n\n\n\n\n\nYes\n\n\n\"owin.ResponseProtocol\"\n\n\nthis.response.protocol\n\n\nAn optional \nstring\n containing the protocol name and version (e.g. \n\"COAP/1.0\"\n, \n\"HTTP/1.1\"\n, or \n\"MQTT/3.1.1\"\n). If none is provided then the \u201cowin.RequestProtocol\u201d key\u2019s value is the default.\n\n\n\n\n\n\n\n\n3.2.3 Other Data\n\n\n\n\n\n\n\n\nRequired\n\n\nOWIN-JS Key Name\n\n\nRecommended Aliases\n\n\nValue Description\n\n\n\n\n\n\n\n\n\n\nYes\n\n\n\"owin.CallCancelled\"\n\n\nthis.owin.callCancelled\n\n\nA CancellationToken indicating if the request has been cancelled/aborted. See \nRequest Lifetime\n.\n\n\n\n\n\n\nYes\n\n\n\"owin.Version\"\n\n\nthis.owin.version\n\n\nThe string \n\"1.2\"\n indicating OWIN-JS version. See \nVersioning\n.\n\n\n\n\n\n\n\n\n3.2.4 Common Keys\n\n\nIn addition to the keys above the host, server, middleware, application, etc. may add arbitrary data associated with the request or response to the environment dictionary.  Guidelines for additional keys and a list of commonly defined keys can be found in \nCommonKeys\n.\n\n\n3.3. Headers\n\n\nThe headers/options of the HTTP/COAP/MQTT request and response messages are represented by objects of type \nIDictionary\n (C#) / object \n{\"key\" : \"value\"}\n (ECMAScript). The requirements below are predicated on \nRFC 2616 section 4.2\n.\n\n\n\n\nThe dictionary MUST be mutable.\n\n\nKeys MUST be HTTP/COAP/MQTT field-names without \n':'\n or whitespace.\n\n\nKeys MUST be compared using OrdinalIgnoreCase.\n\n\nAll characters in key and value strings SHOULD be within the ASCII codepage.\n\n\nThe value array returned is assumed to be a copy of the data. Any intended changes to the value array MUST be persisted back to the headers dictionary manually by via headers[headerName] = modifiedArray; or headers.Remove(header).\n\n\nHeader values are assumed to be in a mixed format, meaning that a normally comma separated header may appear as a single entry in the values array, one entry per value, or a mixture of the two.\n\n\nServers, applications, and intermediaries SHOULD NOT split or merge header values unnecessarily. While the three formats are supposed to be interchangeable, in practice many existing implementations only support one specific format. Developers should have the flexibility to support existing implementations by producing or consuming a selected format without interference.\n\n\n\n\n3.4. Request body, 100 Continue, and Completed Semantics\n\n\nIf the request indicates there is an associated body the server SHOULD provide a Stream/BufferList in the \nowin.RequestBody\n key to access the body data. Stream.Null MAY be used as a placeholder if there is no request body data expected. If the request Expect header indicates the client requests a 100 Continue, it is up to the server to provide owin. The application MUST NOT set \u201cowin.ResponseStatusCode\u201d to 100. 100 Continue is only an intermediate response and using it would prevent the application from providing a final response (e.g. 200 OK). \n\n\n\n\nThe application delegate SHOULD NOT complete its returned Task and return control to the server until it is finished with the request body. Once the AppFunc Task is complete the application SHOULD NOT continue to read from the request stream.\n\n\nThe application MUST signal completion or failure of the response body by completing its returned Task or throwing an exception. After completing the Task, the application SHOULD NOT write any further data to the stream.\n\n\nIf the server signals the \u201cowin.CallCancelled\u201d CancellationToken during the execution of the application delegate, the application SHOULD NOT attempt further reads from the stream, and SHOULD promptly complete the application delegate Task.\n\n\nThe application SHOULD NOT close or dispose the given stream unless it has completely consumed the request body. The stream owner (e.g. the server or middleware) MUST do any necessary cleanup once the application delegate\u2019s Task completes.\n\n\nAny exceptions thrown from the request body stream are fatal and SHOULD be returned to the server by being thrown synchronously from the AppFunc or by failing the asynchronous Task with the given exception(s).\n\n\n\n\n3.5. Response Body\n\n\nThe server provides a response body Stream with the \nowin.ResponseBody\n key in the initial environment dictionary. The headers, status code, reason phrase, etc., can be modified up until the first write to the response body stream. Upon first write, the server validates and sends the headers.Applications MAY choose to buffer response data to delay the header finalization.\n\n\n\n\nThe application MUST signal completion or failure of the body by completing its returned Task or throwing an exception. After completing the Task, the application SHOULD NOT write any further data to the stream.\n\n\nIf the server signals the \nowin.CallCancelled\n CancellationToken during the execution of the application delegate, the application SHOULD NOT attempt further writes to the stream, and SHOULD promptly complete the application delegate Task.\n\n\nThe application SHOULD NOT close or dispose the given stream as middleware may append additional data. The stream owner (e.g. the server or middleware) MUST perform any necessary cleanup once the application delegate\u2019s Task completes.\n\n\n\n\n\n\nAn application SHOULD NOT assume the given stream supports multiple outstanding asynchronous writes. The application developer SHOULD verify that the server and all middleware in use support this pattern before attempting to use it.\n\n\n\n\n3.6. Request lifetime\n\n\nThe full scope or lifetime of a request is limited by the several factors, including the client, server, and application delegate. In the simplest scenario a request\u2019s lifetime ends when the application delegate has completed and the server gracefully ends the request. Failures at any level may cause the request to terminate prematurely, or may be handled internally and allow the request to continue.\n\n\nThe \n\"owin.CallCancelled\"\n key is associated with a CancellationToken that the server uses to signal if the request has be aborted. This SHOULD be triggered if the request becomes faulted before the AppFunc Task is completed. It MAY be triggered at any point at the providers discretion. Middleware MAY replace this token with their own to provide added granularity or functionality, but they SHOULD chain their new token with the one originally provided to them.\n\n\n4. Application Startup\n\n\nWhen the host process starts there are a number of steps it goes through to set up the application.\n\n\n\n\n\n\nThe host creates a Properties Dictionary and populates any startup data or capabilities provided by the host.\n\n\n\n\n\n\nThe host selects which server will be used and provides it with the Properties collection so it can similarly announce any capabilities.\n\n\n\n\n\n\nThe host locates the application setup code and invokes it with the Properties collection.\n\n\n\n\n\n\nThe application reads and/or sets configuration in the Properties collection, constructs the desired request processing pipeline, and returns the resulting application delegate.\n\n\n\n\n\n\nThe host invokes the server startup code with the given application delegate and the Properties dictionary. The server finishes configuring itself, starts accepting requests, and invokes the application delegate to process those requests.\n\n\n\n\n\n\nThe Properties dictionary may be used to read or set any configuration parameters supported by the host, server, middleware, or application.\n\n\n\n\n\n\nThe startup properties dictionary MUST be non-null, mutable and MUST contain the keys listed as required in the table below.\n\n\n\n\n\n\nKeys MUST be compared using Ordinal.\n\n\n\n\n\n\nThe values associated with the keys MUST be non-null, unless otherwise specified.\n\n\n\n\n\n\n\n\n\n\n\n\nRequired\n\n\nOWIN-JS Key Name\n\n\nRecommended Aliases\n\n\nValue Description\n\n\n\n\n\n\n\n\n\n\nYes\n\n\n\"owin.Version\"\n\n\nthis.owin.version\n\n\nThe string \n\"1.2\"\n indicating OWIN-JS version. Added by the server in step 2 above. See \nVersioning\n.\n\n\n\n\n\n\n\n\nIn addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the application configuration to the properties dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in \nCommonKeys.html\n.\n\n\n5. URI Reconstruction\n\n\nApplications often require the ability to reconstruct the complete URI of a request. This process cannot be perfect since HTTP clients do not usually transmit the complete URI which they are requesting, but OWIN-JS makes provisions for the purpose of reconstructing the approximate URI of a request.\n\n\n5.1. URI Scheme\n\n\nThis information is usually not transmitted by an HTTP client and depending on network configuration it may not be possible for an OWIN-JS server to determine a correct value. In these cases, the server may have to manually configure or compute a value.\n\n\nServers MUST provide a best-guess value for \nowin.RequestScheme\n.\n\n\n5.2. Hostname\n\n\nIn the context of an HTTP/1.1 request, the name of the server to which the client is making a request is usually indicated in the Host header field-value of the request, although it might be specified using an absolute Request-URI (see RFC 2616, sections \n5.1.2\n, \n19.6.1.1\n).\n\n\nIn the context of an COAP request or MQTT request, the name of the server is usually given on startup.\n\n\nA server MUST provide a value for the \n\"Host\"\n key in the request header dictionary. The format of the value MUST be \"[:]\". The value SHOULD be deduced by the host using the following steps:\n\n\n\n\nIf the Request-URI of the incoming request is an absolute URI, the value of the \n\"Host\"\n key MUST be taken from the host part of the absolute URI.\n\n\nIf the Request-URI of the incoming request is not an absolute URI, the value of the \n\"Host\"\n key MUST be taken from the Host header field-value of the incoming request.\n\n\nIf the Host header is not present in the incoming request (as in an HTTP/1.0 request), or if its value consists entirely of linear whitespace, the server MUST provide a sensible best-guess value for the \n\"Host\"\n key.\n\n\n\n\n5.3. Paths\n\n\nServers may have the ability to map application delegates to some base path. For example, a server might have an application delegate configured to respond to requests beginning with \n\"/my-app\"\n, in which case it should set the value of \nowin.RequestPathBase\n in the environment dictionary to \n\"/my-app\"\n. If this server receives a request for \n\"/my-app/foo\"\n, the \u201c\nowin.RequestPath\n value of the environment dictionary provided to the application configured to respond at \n\"/my-app\"\n should be \n\"/foo\"\n.\n\n\n\n\n\n\nThe value associated with the environment key \nowin.RequestPathBase\n MUST NOT end with a slash and MUST either start with a slash or be \n\"\"\n.\n\n\n\n\n\n\nThe value associated with the environment key \nowin.RequestPath\n MUST start with a slash, or MAY be \n\"\"\n if the value associated with \nowin.Request.PathBase\n is not string.empty.\n\n\n\n\n\n\n5.4. URI Reconstruction Algorithm\n\n\nThe following algorithm can be used to approximate the complete URI of the current request:\n\n\nC#\n\n\nvar uri =\n  (string)Environment[\"owin.RequestScheme\"] + \n   \"\"://\" +\n   Headers[\"Host\"].First() +\n  (string)Environment[\"owin.RequestPathBase\"] +\n  (string)Environment[\"owin.RequestPath\"];\n\nif (Environment[\"owin.RequestQueryString\"] != \"\")\n  uri += \"?\" + (string)Environment[\"owin.RequestQueryString\"];\n\n\n\nThe result of this algorithm may not be identical to the URI the client used to make the request; for example, the server may have done some rewriting to canonicalize the request. Further, it is subject to the caveats described in the \nURI Scheme\n and \nHostname\n sections above.\n\n\n5.5. Percent-encoding\n\n\nA URI uses percent encoding to transport characters outside its normally allowed character rules (\nRFC 3986\n section 2). Percent-encoding is used to express the underlying octets present in a URI component, whose octets are interpreted via UTF-8 encoding. Most web server implementations will perform percent-decoding on paths in order to perform request routing (as they rightly may, see: RFC 2616 section \n5.1.2\n, also \n3.2.3\n), and OWIN-JS follows this precedent. The request query string in OWIN-JS is presented in its percent-encoded form; a percent-decoded query string could contain \n'?'\n or \n'='\n characters, which would render the string unparseable.\n\n\n\n\nThe server MUST provide percent-decoded values for \nowin.Request.Path\n and \nowin.Request.PathBase\n.\n\n\nThe server MUST provide a percent-encoded value for \nowin.Request.QueryString\n\n\n\n\n6. Error Handling\n\n\nWhile there are standard exceptions such as ArgumentException and IOException that may be expected in normal request processing scenarios, handling only such exceptions is insufficient when building a robust server or application. If a server wishes to be robust it SHOULD consistently address all exception types thrown or returned from the application delegate or body delegate. The handling mechanism (e.g. logging, crashing and restarting, swallowing, etc.) is up to the server and host process.\n\n\n6.1. Application Errors\n\n\nAn application may generate an exception in the following places:\n\n\n\n\nThrown from an invocation of the application delegate.\n\n\nProvided as the result of the application delegate Task.\n\n\n\n\nAn application SHOULD attempt to trap its own internal errors and generate an appropriate (possibly 500-level) response rather than propagating an exception up to the server.\n\n\nAfter an application provides a response, the server SHOULD wait to receive at least one write from the response Stream before writing the response headers to the underlying transport. In this way, if instead of a write to the Stream the server gets an exception from the application delegate Task, the server will still be able to generate a 500-level response. If the server gets a write to the Stream first, it can safely assume that the application has caught as many of its internal errors as possible; the server can begin sending the response. If an exception is subsequently received, the server MAY handle it as it sees fit (e.g. logging, write a textual description of the error to the underlying transport, and/or close the connection).\n\n\n6.2. Server Errors\n\n\nWhen a server encounters errors during a request\u2019s lifetime it SHOULD signal the CancellationToken it provided in \nowin.CallCancelled\n. The server MAY then take any necessary actions to terminate the request, but it SHOULD be tolerant of completion delays of the application delegate.\n\n\n7. Versioning\n\n\nFuture updates to this standard may contain breaking changes (e.g. signature changes, key additions or modifications, etc.) or non-breaking additions. While addressing specific changes is the responsibility of later versions of the standard, here are initial guidelines for expected changes:\n\n\n\n\n\n\nThis standard uses Semantic Versioning as described at  (e.g. Major.Minor.Patch).\n\n\n\n\n\n\nBreaking changes to the API signatures or existing keys will require incrementing the major version number (e.g. OWIN-JS 2.0)\n\n\n\n\n\n\nAdding new keys or delegates in a backwards compatible way only requires incrementing the minor version number (e.g. OWIN-JS 1.1).\n\n\n\n\n\n\nMaking corrections and clarifications to the document alone only requires incrementing the patch version number and last modified date (e.g. OWIN-JS 1.0.1).\n\n\n\n\n\n\nThe \n\"owin.Version\"\n key in the startup Properties and request Environment dictionaries indicates the latest version of the standard implemented by the server and may be used to dynamically adjust behaviors of applications.  Major and Minor versions are kept consistent on OWIN-JS to match OWIN as far as practical.\n\n\n\n\n\n\nAll implementers SHOULD clearly document the full version number(s) of the OWIN-JS standard they support.\n\n\n\n\n\n\nThe keys listed in \nCommonKeys\n are strictly optional. Additions may be made there without directly affecting the OWIN-JS standard or version number.\n\n\n\n\n\n\n8. Extensions\n\n\n\n\n\n\n\n\nExtension\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCommon Keys\n\n\nGuidelines for exending OWIN-JS via extension keys in the various IDictionaries.\n\n\n\n\n\n\nAppBuilder\n\n\nAppBuilder (implementation)\n\n\n\n\n\n\nOpaque\n\n\nOWIN-JS Opaque Stream Extension.\n\n\n\n\n\n\nWebSocket\n\n\nOWIN-JS WebSocket Extension.\n\n\n\n\n\n\nPubSub\n\n\nOWIN-JS PubSub Extension.\n\n\n\n\n\n\nnodekit\n\n\nExtensions to support the nodekit.io project\n\n\n\n\n\n\n\n\n9. Real World Usage\n\n\n\n\n\n\n\n\nExtension\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAppBuilder\n\n\nReal word usage of AppBuilder Pipeline", 
            "title": "OWIN-JS"
        }, 
        {
            "location": "/Specification/#specification-v120-release", 
            "text": "Title: Open Web Interface for Node.js (OWIN-JS)  Author : OWIN-JS working group  Ported from:  OWIN  (authored by OWIN working group)  Copyright : OWIN-JS contributors, OWIN Contributors  License :  Creative Commons Attribution 3.0 Unported License", 
            "title": "Specification v1.2.0 RELEASE"
        }, 
        {
            "location": "/Specification/#contents", 
            "text": "1.  Overview  2.  Definitions  3.  Request Execution  3.1.  Application Delegate  3.2.  Environment  3.3.  Headers  3.4.  Request Body  3.5.  Response Body  3.6.  Request Lifetime  4.  Application Startup  5.  URI Reconstruction  5.1.  URI Scheme  5.2.  Hostname  5.3.  Paths  5.4.  URI Reconstruction Algorithm  5.5.  Percent-encoding  6.  Error Handling  6.1.  Application Errors  6.2.  Server Errors  7.  Versioning  8.  Extensions  9.  Real World Usage", 
            "title": "Contents"
        }, 
        {
            "location": "/Specification/#146-overview", 
            "text": "This document defines the Open Web Interface for Node.js (OWIN-JS), a standard framework for REST servers for io.js, Node.js and backwards compatible with .NET.    OWIN-JS is targeted for multiple transport providers including HTTP, COAP and MQTT servers, and can be a drop-in replacement for existing frameworks such as Connect/Express on Node.js.   It defines a standard way that application/device logic can rely on REST server capabilities without being tied to any one transport (http, express, koa, node-coap, mosca, etc.)   OWIN-JS is a port of the  OWIN  specification, but expands the REST philosophy to web servers, application clients, desktop/mobile apps, etc.    See also  OWIN-D  for an extension of this OWIN-JS specification that specifically targets devices and accessories in the Internet of Things, and see example applications such as  nodekit.io  that show how OWIN-JS can enable a standalone desktop app.  OWIN-JS is defined in terms of a delegate structure. There is no assembly. Implementing either the host or application side the OWIN-JS spec does not introduce a dependency to a project.  In this document, the Node.js  function  and C#  Action / Func  syntax is used to notate some delegate structures.   However, the delegate structure could be equivalently represented with other native functions, CLR interfaces, or named delegates. This is by design; when implementing OWIN-JS, choose a delegate representation that works for you and your stack.  The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in  RFC 2119 .", 
            "title": "1. Overview"
        }, 
        {
            "location": "/Specification/#246-definitions", 
            "text": "This document refers to the following software actors:    Server \u2013 The REST server (typically HTTP, COAP or MQTT) that directly communicates with the client and then uses OWIN-JS semantics to process requests. Servers may require an adapter layer that converts to OWIN-JS semantics.    Framework \u2013 A self-contained component based on OWIN-JS exposing its own object model or API that applications may use to facilitate request processing. Frameworks may require an adapter layer that converts from OWIN-JS semantics.    Application \u2013 A specific application or device logic, possibly built on top of a Web Framework, which is run using OWIN-JS compatible Servers.    Middleware \u2013 Pass through components that form a pipeline between a server and application to inspect, route, or modify request and response messages for a specific purpose.    Host \u2013 The process an application and server execute inside of, primarily responsible for application startup. Some Servers are also Hosts.", 
            "title": "2. Definitions"
        }, 
        {
            "location": "/Specification/#346-request-execution", 
            "text": "Broadly speaking, a server invokes an application (providing as arguments an environment dictionary with request and response headers and bodies); an application either populates a response or indicates an error.  3.1. Application Delegate  The primary interface in OWIN-JS is called the  application delegate  or  AppFunc . An application delegate takes the Dictionary environment and returns a Promise or a Task when it has finished processing.  Node.js AppFunc (returns a Promise/A)  var myAppFuncPromise = function() {...};  where  this  is set to the Dictionary environment and  myAppFuncPromise  is a Promise/A promise that can be chained with      myAppFuncPromise.then(... , ... )  etc.  .NET  using AppFunc = Func \n    IDictionary string, object , // Environment\n    Task ; // Done   The application MUST eventually complete the returned  task/promise , or throw an exception.   3.2. Environment  The Environment object stores information about the request, the response, and any relevant server state.  The server is responsible for providing body streams and header collections for both the request and response in the initial call. The application then populates the appropriate fields with response data, writes the response body, and returns when done.    The environment object MUST be non-null, mutable and MUST contain the keys listed as required in the tables below (listed under  OWIN-JS Key Name  column title)    Keys MUST be compared using StringComparer.Ordinal.    The values associated with the keys MUST be non-null, unless otherwise specified.    The implementation MAY provide aliases that are convenient to access in the selected programming language chosen (i.e., ECMAScript/JavaScript, C#) to avoid  context[\"owin.Key\"]  type accessors in favor of  this.owinKey  (for intellitype, strong typing, capitalization conventions, separation of  request  and  response  objects, etc.).      If a server does not implement alias names, middleware such as  OWIN-JS/owin-js  MAY be used to add such alias names.      Alias names used by the OwinJS/owinjs reference implementation and indicated in the table below, are RECOMMENDED as the preferred naming convention.  Additional aliases or helper functions MAY be provided in addition to these.    Where provided, alias property getters and setters MUST ensure continued synchronization with the original environment dictionary property (i.e., these are reference  mirrors  not value  copies ).      Periods in  OWIN-JS Key Names  are considered part of the single string and therefore require quotes for access in most C-style languages (e.g.,  var body = context[\"owin.RequestBody\"]; ).    Periods in  alias names  indicate separate layers in the object hierarchy (e.g.,  context  object contains a  request  alias property which contains a  body  property, a  path  string, a  pathBase  string etc.).  All aliases key names SHOULD be in  camelCase  capitalization.   (e.g.,  var body = this.request.body; )    Implementations of OWIN-JS servers and/or middleware harnesses MAY omit the context variable as an explicit parameter for applications and middleware functions and instead set the base language's context object (e.g.,  this  in ECMAScript/Javascript).    The environment dictionary SHOULD allow additional prototype methods to be added to its prototype object, to facilitate alias implementations that are defined once per server instance, not once per request    3.2.1 Request Data     Required  OWIN-JS Key Name  Recommended Aliases  Value Description      Yes  \"owin.RequestBody\"  this.request.body this.request  A Stream/BufferList with the request payload, if any Stream.  Null MAY be used as a placeholder if there is no request body. See  Request Body .    Yes  \"owin.RequestHeaders\"  this.request.headers  A Dictionary of request headers/options. See  Headers .    Yes  \"owin.RequestMethod\"  this.request.method  A  string  containing the request method of the request (e.g.,  \"GET\" ,  \"PUT\" ,  \"DELETE\" ,  \"POST\" ,  \"CONNECT\" ,  \"SUBSCRIBE\" ).    Yes  \"owin.RequestPath\"  this.request.path  A  string  containing the request path. The path MUST be relative to the \"root\" of the application delegate; see  Paths .    Yes  \"owin.RequestPathBase\"  this.request.pathBase  A  string  containing the portion of the request path corresponding to the \"root\" of the application delegate; see  Paths .    Yes  \"owin.RequestProtocol\"  this.request.protocol  A  string  containing the protocol name and version (e.g.  \"COAP/1.0\" ,  \"HTTP/1.1\" , or  \"MQTT/3.1.1\" ).    Yes  \"owin.RequestQueryString\"  this.request.queryString  A  string  containing the query string component of the request URI, without the leading \u201c?\u201d (e.g.,  \"foo=bar amp;baz=quux\" ). The value may be an empty string.    Yes  \"owin.RequestScheme\"  this.request.scheme  A  string  containing the URI scheme used for the request (e.g.,  \"http\" ,  \"coap\" ,  \"https\" ,  \"mqtt\" ); see  URI Scheme .     3.2.2 Response Data     Required  OWIN-JS Key Name  Recommended Aliases  Value Description      Yes  \"owin.ResponseBody\"  this.response.body this.response  A Stream/BufferList used to write/append the response payload, if any. See  Response Body .    Yes  \"owin.ResponseHeaders\"  this.response.headers  A Dictionary of response headers/options. See  Headers .    Yes  \"owin.ResponseStatusCode\"  this.response.statusCode  An optional  integer  containing the REST response status code as defined by the transport protocol (COAP, HTTP or MQTT).    Yes  \"owin.ResponseReasonPhrase\"  this.response.reasonPhrase  An optional  string  containing the reason phrase associated the given status code. If none is provided then the server SHOULD provide a default as described in  RFC 2616  section 6.1.1    Yes  \"owin.ResponseProtocol\"  this.response.protocol  An optional  string  containing the protocol name and version (e.g.  \"COAP/1.0\" ,  \"HTTP/1.1\" , or  \"MQTT/3.1.1\" ). If none is provided then the \u201cowin.RequestProtocol\u201d key\u2019s value is the default.     3.2.3 Other Data     Required  OWIN-JS Key Name  Recommended Aliases  Value Description      Yes  \"owin.CallCancelled\"  this.owin.callCancelled  A CancellationToken indicating if the request has been cancelled/aborted. See  Request Lifetime .    Yes  \"owin.Version\"  this.owin.version  The string  \"1.2\"  indicating OWIN-JS version. See  Versioning .     3.2.4 Common Keys  In addition to the keys above the host, server, middleware, application, etc. may add arbitrary data associated with the request or response to the environment dictionary.  Guidelines for additional keys and a list of commonly defined keys can be found in  CommonKeys .  3.3. Headers  The headers/options of the HTTP/COAP/MQTT request and response messages are represented by objects of type  IDictionary  (C#) / object  {\"key\" : \"value\"}  (ECMAScript). The requirements below are predicated on  RFC 2616 section 4.2 .   The dictionary MUST be mutable.  Keys MUST be HTTP/COAP/MQTT field-names without  ':'  or whitespace.  Keys MUST be compared using OrdinalIgnoreCase.  All characters in key and value strings SHOULD be within the ASCII codepage.  The value array returned is assumed to be a copy of the data. Any intended changes to the value array MUST be persisted back to the headers dictionary manually by via headers[headerName] = modifiedArray; or headers.Remove(header).  Header values are assumed to be in a mixed format, meaning that a normally comma separated header may appear as a single entry in the values array, one entry per value, or a mixture of the two.  Servers, applications, and intermediaries SHOULD NOT split or merge header values unnecessarily. While the three formats are supposed to be interchangeable, in practice many existing implementations only support one specific format. Developers should have the flexibility to support existing implementations by producing or consuming a selected format without interference.   3.4. Request body, 100 Continue, and Completed Semantics  If the request indicates there is an associated body the server SHOULD provide a Stream/BufferList in the  owin.RequestBody  key to access the body data. Stream.Null MAY be used as a placeholder if there is no request body data expected. If the request Expect header indicates the client requests a 100 Continue, it is up to the server to provide owin. The application MUST NOT set \u201cowin.ResponseStatusCode\u201d to 100. 100 Continue is only an intermediate response and using it would prevent the application from providing a final response (e.g. 200 OK).    The application delegate SHOULD NOT complete its returned Task and return control to the server until it is finished with the request body. Once the AppFunc Task is complete the application SHOULD NOT continue to read from the request stream.  The application MUST signal completion or failure of the response body by completing its returned Task or throwing an exception. After completing the Task, the application SHOULD NOT write any further data to the stream.  If the server signals the \u201cowin.CallCancelled\u201d CancellationToken during the execution of the application delegate, the application SHOULD NOT attempt further reads from the stream, and SHOULD promptly complete the application delegate Task.  The application SHOULD NOT close or dispose the given stream unless it has completely consumed the request body. The stream owner (e.g. the server or middleware) MUST do any necessary cleanup once the application delegate\u2019s Task completes.  Any exceptions thrown from the request body stream are fatal and SHOULD be returned to the server by being thrown synchronously from the AppFunc or by failing the asynchronous Task with the given exception(s).   3.5. Response Body  The server provides a response body Stream with the  owin.ResponseBody  key in the initial environment dictionary. The headers, status code, reason phrase, etc., can be modified up until the first write to the response body stream. Upon first write, the server validates and sends the headers.Applications MAY choose to buffer response data to delay the header finalization.   The application MUST signal completion or failure of the body by completing its returned Task or throwing an exception. After completing the Task, the application SHOULD NOT write any further data to the stream.  If the server signals the  owin.CallCancelled  CancellationToken during the execution of the application delegate, the application SHOULD NOT attempt further writes to the stream, and SHOULD promptly complete the application delegate Task.  The application SHOULD NOT close or dispose the given stream as middleware may append additional data. The stream owner (e.g. the server or middleware) MUST perform any necessary cleanup once the application delegate\u2019s Task completes.    An application SHOULD NOT assume the given stream supports multiple outstanding asynchronous writes. The application developer SHOULD verify that the server and all middleware in use support this pattern before attempting to use it.   3.6. Request lifetime  The full scope or lifetime of a request is limited by the several factors, including the client, server, and application delegate. In the simplest scenario a request\u2019s lifetime ends when the application delegate has completed and the server gracefully ends the request. Failures at any level may cause the request to terminate prematurely, or may be handled internally and allow the request to continue.  The  \"owin.CallCancelled\"  key is associated with a CancellationToken that the server uses to signal if the request has be aborted. This SHOULD be triggered if the request becomes faulted before the AppFunc Task is completed. It MAY be triggered at any point at the providers discretion. Middleware MAY replace this token with their own to provide added granularity or functionality, but they SHOULD chain their new token with the one originally provided to them.", 
            "title": "3. Request Execution"
        }, 
        {
            "location": "/Specification/#446-application-startup", 
            "text": "When the host process starts there are a number of steps it goes through to set up the application.    The host creates a Properties Dictionary and populates any startup data or capabilities provided by the host.    The host selects which server will be used and provides it with the Properties collection so it can similarly announce any capabilities.    The host locates the application setup code and invokes it with the Properties collection.    The application reads and/or sets configuration in the Properties collection, constructs the desired request processing pipeline, and returns the resulting application delegate.    The host invokes the server startup code with the given application delegate and the Properties dictionary. The server finishes configuring itself, starts accepting requests, and invokes the application delegate to process those requests.    The Properties dictionary may be used to read or set any configuration parameters supported by the host, server, middleware, or application.    The startup properties dictionary MUST be non-null, mutable and MUST contain the keys listed as required in the table below.    Keys MUST be compared using Ordinal.    The values associated with the keys MUST be non-null, unless otherwise specified.       Required  OWIN-JS Key Name  Recommended Aliases  Value Description      Yes  \"owin.Version\"  this.owin.version  The string  \"1.2\"  indicating OWIN-JS version. Added by the server in step 2 above. See  Versioning .     In addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the application configuration to the properties dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in  CommonKeys.html .", 
            "title": "4. Application Startup"
        }, 
        {
            "location": "/Specification/#5-uri-reconstruction", 
            "text": "Applications often require the ability to reconstruct the complete URI of a request. This process cannot be perfect since HTTP clients do not usually transmit the complete URI which they are requesting, but OWIN-JS makes provisions for the purpose of reconstructing the approximate URI of a request.  5.1. URI Scheme  This information is usually not transmitted by an HTTP client and depending on network configuration it may not be possible for an OWIN-JS server to determine a correct value. In these cases, the server may have to manually configure or compute a value.  Servers MUST provide a best-guess value for  owin.RequestScheme .  5.2. Hostname  In the context of an HTTP/1.1 request, the name of the server to which the client is making a request is usually indicated in the Host header field-value of the request, although it might be specified using an absolute Request-URI (see RFC 2616, sections  5.1.2 ,  19.6.1.1 ).  In the context of an COAP request or MQTT request, the name of the server is usually given on startup.  A server MUST provide a value for the  \"Host\"  key in the request header dictionary. The format of the value MUST be \"[:]\". The value SHOULD be deduced by the host using the following steps:   If the Request-URI of the incoming request is an absolute URI, the value of the  \"Host\"  key MUST be taken from the host part of the absolute URI.  If the Request-URI of the incoming request is not an absolute URI, the value of the  \"Host\"  key MUST be taken from the Host header field-value of the incoming request.  If the Host header is not present in the incoming request (as in an HTTP/1.0 request), or if its value consists entirely of linear whitespace, the server MUST provide a sensible best-guess value for the  \"Host\"  key.   5.3. Paths  Servers may have the ability to map application delegates to some base path. For example, a server might have an application delegate configured to respond to requests beginning with  \"/my-app\" , in which case it should set the value of  owin.RequestPathBase  in the environment dictionary to  \"/my-app\" . If this server receives a request for  \"/my-app/foo\" , the \u201c owin.RequestPath  value of the environment dictionary provided to the application configured to respond at  \"/my-app\"  should be  \"/foo\" .    The value associated with the environment key  owin.RequestPathBase  MUST NOT end with a slash and MUST either start with a slash or be  \"\" .    The value associated with the environment key  owin.RequestPath  MUST start with a slash, or MAY be  \"\"  if the value associated with  owin.Request.PathBase  is not string.empty.    5.4. URI Reconstruction Algorithm  The following algorithm can be used to approximate the complete URI of the current request:  C#  var uri =\n  (string)Environment[\"owin.RequestScheme\"] + \n   \"\"://\" +\n   Headers[\"Host\"].First() +\n  (string)Environment[\"owin.RequestPathBase\"] +\n  (string)Environment[\"owin.RequestPath\"];\n\nif (Environment[\"owin.RequestQueryString\"] != \"\")\n  uri += \"?\" + (string)Environment[\"owin.RequestQueryString\"];  The result of this algorithm may not be identical to the URI the client used to make the request; for example, the server may have done some rewriting to canonicalize the request. Further, it is subject to the caveats described in the  URI Scheme  and  Hostname  sections above.  5.5. Percent-encoding  A URI uses percent encoding to transport characters outside its normally allowed character rules ( RFC 3986  section 2). Percent-encoding is used to express the underlying octets present in a URI component, whose octets are interpreted via UTF-8 encoding. Most web server implementations will perform percent-decoding on paths in order to perform request routing (as they rightly may, see: RFC 2616 section  5.1.2 , also  3.2.3 ), and OWIN-JS follows this precedent. The request query string in OWIN-JS is presented in its percent-encoded form; a percent-decoded query string could contain  '?'  or  '='  characters, which would render the string unparseable.   The server MUST provide percent-decoded values for  owin.Request.Path  and  owin.Request.PathBase .  The server MUST provide a percent-encoded value for  owin.Request.QueryString", 
            "title": "5. URI Reconstruction"
        }, 
        {
            "location": "/Specification/#6-error-handling", 
            "text": "While there are standard exceptions such as ArgumentException and IOException that may be expected in normal request processing scenarios, handling only such exceptions is insufficient when building a robust server or application. If a server wishes to be robust it SHOULD consistently address all exception types thrown or returned from the application delegate or body delegate. The handling mechanism (e.g. logging, crashing and restarting, swallowing, etc.) is up to the server and host process.  6.1. Application Errors  An application may generate an exception in the following places:   Thrown from an invocation of the application delegate.  Provided as the result of the application delegate Task.   An application SHOULD attempt to trap its own internal errors and generate an appropriate (possibly 500-level) response rather than propagating an exception up to the server.  After an application provides a response, the server SHOULD wait to receive at least one write from the response Stream before writing the response headers to the underlying transport. In this way, if instead of a write to the Stream the server gets an exception from the application delegate Task, the server will still be able to generate a 500-level response. If the server gets a write to the Stream first, it can safely assume that the application has caught as many of its internal errors as possible; the server can begin sending the response. If an exception is subsequently received, the server MAY handle it as it sees fit (e.g. logging, write a textual description of the error to the underlying transport, and/or close the connection).  6.2. Server Errors  When a server encounters errors during a request\u2019s lifetime it SHOULD signal the CancellationToken it provided in  owin.CallCancelled . The server MAY then take any necessary actions to terminate the request, but it SHOULD be tolerant of completion delays of the application delegate.", 
            "title": "6. Error Handling"
        }, 
        {
            "location": "/Specification/#746-versioning", 
            "text": "Future updates to this standard may contain breaking changes (e.g. signature changes, key additions or modifications, etc.) or non-breaking additions. While addressing specific changes is the responsibility of later versions of the standard, here are initial guidelines for expected changes:    This standard uses Semantic Versioning as described at  (e.g. Major.Minor.Patch).    Breaking changes to the API signatures or existing keys will require incrementing the major version number (e.g. OWIN-JS 2.0)    Adding new keys or delegates in a backwards compatible way only requires incrementing the minor version number (e.g. OWIN-JS 1.1).    Making corrections and clarifications to the document alone only requires incrementing the patch version number and last modified date (e.g. OWIN-JS 1.0.1).    The  \"owin.Version\"  key in the startup Properties and request Environment dictionaries indicates the latest version of the standard implemented by the server and may be used to dynamically adjust behaviors of applications.  Major and Minor versions are kept consistent on OWIN-JS to match OWIN as far as practical.    All implementers SHOULD clearly document the full version number(s) of the OWIN-JS standard they support.    The keys listed in  CommonKeys  are strictly optional. Additions may be made there without directly affecting the OWIN-JS standard or version number.", 
            "title": "7. Versioning"
        }, 
        {
            "location": "/Specification/#846-extensions", 
            "text": "Extension  Description      Common Keys  Guidelines for exending OWIN-JS via extension keys in the various IDictionaries.    AppBuilder  AppBuilder (implementation)    Opaque  OWIN-JS Opaque Stream Extension.    WebSocket  OWIN-JS WebSocket Extension.    PubSub  OWIN-JS PubSub Extension.    nodekit  Extensions to support the nodekit.io project", 
            "title": "8. Extensions"
        }, 
        {
            "location": "/Specification/#946-real-world-usage", 
            "text": "Extension  Description      AppBuilder  Real word usage of AppBuilder Pipeline", 
            "title": "9. Real World Usage"
        }, 
        {
            "location": "/CommonKeys/", 
            "text": "Common Keys\n\n\n\n\nAuthor : OWIN-JS working group\n\n\nPorted from: \nOWIN\n (authored by OWIN working group)\n\n\nCopyright : OWIN-JS contributors, OWIN Contributors\n\n\nLicense : \nCreative Commons Attribution 3.0 Unported License\n\n\n\n\nContents\n\n\n\n\n\n\nOverview\n\n\n\n\n\n\nKey usage guidelines\n\n\n\n\n\n\nNaming conventions\n\n\n\n\n\n\nValue conventions\n\n\n\n\n\n\nCapabilities announcement and detection\n\n\n\n\n\n\nCommon keys\n\n\n\n\n\n\n1. Overview\n\n\nThis document contains guidelines for adding functionality to OWIN-JS based servers or application via additional keys in the Dictionary object (e.g. the request environment or the startup properties). This includes naming conventions, value conventions, and a list of know common keys and their semantics.\n\n\nThese guidelines and keys are provided independently of the OWIN specification as the list of common keys below is expected to grow independently of the OWIN standard.\n\n\nThe following guidelines apply to the keys and values specifically listed below, as well as for custom keys and values defined by individual implementations.\n\n\n2. Key usage guidelines\n\n\nThe Dictionary object can be used to extend the OWIN-JS interface with additional functionality.\n\n\n\n\n\n\nAll keys MUST be compared using Ordinal.\n\n\n\n\n\n\nAll keys not defined in the OWIN-JS standard are considered extension keys and are strictly optional.\n\n\n\n\n\n\nImplementers SHOULD clearly document what keys their component will populate, under what conditions, and the types and semantics of the associated values.\n\n\n\n\n\n\n3. Naming conventions\n\n\nThe Dictionary objects are open and mutable for storing arbitrary data. To avoid collisions between components, the following key naming conventions SHOULD be honored.\n\n\n\n\n\n\nKey names are Ordinal (case sensitive, culture insensitive) strings.\n\n\n\n\n\n\nMost keys SHOULD be composed of a lower case prefix, a period, and a Pascal cased descriptor (e.g. owin.RequestMethod).\n\n\n\n\n\n\nA number of common keys are listed later in this document. These keys use general prefixes such as server.* to indicate that this is data that may be provided by many different implementations. Implementers SHOULD favor using such shared keys rather than defining their own.\n\n\n\n\n\n\nKeys that refer to a common technology group SHOULD be prefixed with a name that identifies that technology. E.g. ssl.\n or websocket.\n.\n\n\n\n\n\n\nKeys that expose functionality specific to a single implementation SHOULD use a prefix that clearly identifies that implementation. E.g. \niis.*\n, \nhttplistener.*\n, \nwebapi.*\n, \nmymiddleware.*\n.\n\n\n\n\n\n\nImplementers SHOULD avoid defining keys that differ only subtly from existing keys (e.g. casing, spelling, etc.).\n\n\n\n\n\n\nImplementers SHOULD include a technology specific version key that clearly identifies not only the version of the underlying component, but also the version of any OWIN specific wrapper of that component. E.g. mshttplistener.Version: .NET 4.0, OWIN wrapper 1.0.1. This is intended to help consumers cross reference documentation with implementations, facilitating both development and debugging.\n\n\n\n\n\n\nThe fully qualified name of a type MAY be used as the key, but only if it is reasonable to assume that there will only ever be one instance of this type per request. E.g. \nSystem.Net.HttpListenerContext\n is guaranteed to be unique per request, whereas \nSystem.Security.Cryptography.X509Certificates.X509Certificate\n identifies a specific type but it is ambiguous if the value represents the client certificate, the server certificate, or a certificate for some other purpose.\n\n\n\n\n\n\n4. Value conventions\n\n\nThe type of each value SHOULD be clearly documented by the implementer.\n\n\n\n\n\n\nValues MAY be of a type derived from the type specified in documentation, but the documentation SHOULD state under what conditions it is reasonable to expect such types to be available. Consumers may attempt to cast to more specific derived types (safely using is or as rather than an explicit cast), but SHOULD fall back to the documented base type wherever possible.\n\n\n\n\n\n\nNull values or empty strings SHOULD be treated the same as if the key were not present. Every key SHOULD have at least one defined value, even if the value is the string \"true\".\n\n\n\n\n\n\nImplementers SHOULD avoid populating keys associated with null values or empty strings, but SHOULD be tolerant of such values when retrieving data.\n\n\n\n\n\n\nImplementers MUST NOT overload a single key with multiple types (other than derived types as discussed above). If there are multiple possible representations, use separate keys to clearly identify them.\n\n\n\n\n\n\nAvoid using types that are likely to change signatures between versions.\n\n\n\n\n\n\nPrefer base types (e.g. int, string, etc.) or common types in the .NET framework that have existed for multiple releases (e.g. Stream).\n\n\n\n\n\n\nValues in the request Environment collection are assumed to be alive and accurate only for the lifetime of the request. Consumers SHOULD NOT retain or attempt to use values after a request has completed or failed. Where a value advertises a specific capability, that capability is only assumed to be available for that request instance and SHOULD be re-verified on future requests.\n\n\n\n\n\n\nGlobal capabilities or data SHOULD be communicated as described in section 5 below.\n\n\n\n\n\n\nWhere any specific value cleanup is required (e.g. Dispose), such cleanup is the responsibility of the component that originally added the value. This should be taken care of as the stack unwinds after a request has completed or failed.\n\n\n5. Capabilities announcement and detection\n\n\nIt is important for applications to be able to determine if a specific feature is supported by the current server or middleware. The following pattern is recommended for announcing and detecting feature/extension support.\n\n\n\n\n\n\nAt startup the server SHOULD create a \nserver.Capabilities\n object dictionary in the startup Properties dictionary.\n\n\n\n\n\n\nThis capabilities dictionary is for static capability details that do not change on a per-request basis.\n\n\n\n\n\n\nThe same instance of the capabilities dictionary SHOULD also be included in each request environment dictionary.\n\n\n\n\n\n\nEach extension SHOULD add to the capabilities Dictionary a \nfeaturename.Version\n key with the associated string value of the latest version of that extension supported (e.g. 1.2).\n\n\n\n\n\n\nIf extensions have defined additional keys used to indicate details, the implementer SHOULD add to the capabilities Dicitonary a \nfeaturename.Support\n Dictionary containing the detailed featurename.FeatureDetail keys and their associated values.\n\n\n\n\n\n\nPer-request feature keys and values should be included directly in the environment dictionary.\n\n\n\n\n\n\n6. Common keys\n\n\nKeys and values listed here are those that are anticipated to be common across multiple implementations, but are not strictly required for basic operations.\n\n\n\n\n\n\n\n\nObject Name\n\n\nType\n\n\nStartup\n\n\nRequest\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nssl.ClientCertificate\n\n\nX509Certificate\n\n\n\n\nX\n\n\nThe client certificate provided during HTTPS SSL negotiation.\n\n\n\n\n\n\nserver.RemoteIpAddress\n\n\nString\n\n\n\n\nX\n\n\nThe IP Address of the remote client. E.g. 192.168.1.1 or ::1\n\n\n\n\n\n\nserver.RemotePort\n\n\nString\n\n\n\n\nX\n\n\nThe port of the remote client. e.g. 1234\n\n\n\n\n\n\nserver.LocalIpAddress\n\n\nString\n\n\n\n\nX\n\n\nThe local IP Address the request was received on. E.g. 127.0.0.1 or ::1\n\n\n\n\n\n\nserver.LocalPort\n\n\nString\n\n\n\n\nX\n\n\nThe port the request was received on. E.g. 80\n\n\n\n\n\n\nserver.IsLocal\n\n\nBoolean\n\n\n\n\nX\n\n\nWas the request sent from the same machine? E.g. true or false.\n\n\n\n\n\n\nhost.TraceOutput\n\n\n.log()\n / TextWriter\n\n\nX\n\n\nX\n\n\nA tracing output that may be provided by the host.\n\n\n\n\n\n\nhost.Addresses\n\n\nList Object\n\n\nX\n\n\n\n\nA list of per-address server configuration. The following keys are defined with string values: scheme, host, port, path.\n\n\n\n\n\n\nserver.Capabilities\n\n\nDictionary Object\n\n\nX\n\n\nX\n\n\nGlobal capabilities that do not change on a per-request basis. See Section 5 above.\n\n\n\n\n\n\nserver.OnSendingHeaders\n\n\nfunction\n\n\n\n\nX\n\n\nAllows the caller to register an Action callback that fires as a last chance to modify response headers, status code, reason phrase, or protocol. The object parameter is an optional state object that will passed to the callback\n\n\n\n\n\n\nwebsocket.*\n\n\n\n\nX\n\n\nX\n\n\nSee the WebSocket extension\n\n\n\n\n\n\nsendfile.*\n\n\n\n\nX\n\n\nX\n\n\nSee the SendFile extension\n\n\n\n\n\n\nopaque.*\n\n\n\n\nX\n\n\nX\n\n\nSee the Opaque extension\n\n\n\n\n\n\ncoap.*\n\n\n\n\nX\n\n\nX\n\n\nSee the CoAP extension or limerun/lime-coap\n\n\n\n\n\n\nowind.*\n\n\n\n\nX\n\n\nX\n\n\nSee the OWIN-D extension", 
            "title": "Common Keys"
        }, 
        {
            "location": "/CommonKeys/#common-keys", 
            "text": "Author : OWIN-JS working group  Ported from:  OWIN  (authored by OWIN working group)  Copyright : OWIN-JS contributors, OWIN Contributors  License :  Creative Commons Attribution 3.0 Unported License", 
            "title": "Common Keys"
        }, 
        {
            "location": "/CommonKeys/#contents", 
            "text": "Overview    Key usage guidelines    Naming conventions    Value conventions    Capabilities announcement and detection    Common keys", 
            "title": "Contents"
        }, 
        {
            "location": "/CommonKeys/#1-overview", 
            "text": "This document contains guidelines for adding functionality to OWIN-JS based servers or application via additional keys in the Dictionary object (e.g. the request environment or the startup properties). This includes naming conventions, value conventions, and a list of know common keys and their semantics.  These guidelines and keys are provided independently of the OWIN specification as the list of common keys below is expected to grow independently of the OWIN standard.  The following guidelines apply to the keys and values specifically listed below, as well as for custom keys and values defined by individual implementations.", 
            "title": "1. Overview"
        }, 
        {
            "location": "/CommonKeys/#246-key-usage-guidelines", 
            "text": "The Dictionary object can be used to extend the OWIN-JS interface with additional functionality.    All keys MUST be compared using Ordinal.    All keys not defined in the OWIN-JS standard are considered extension keys and are strictly optional.    Implementers SHOULD clearly document what keys their component will populate, under what conditions, and the types and semantics of the associated values.", 
            "title": "2. Key usage guidelines"
        }, 
        {
            "location": "/CommonKeys/#346-naming-conventions", 
            "text": "The Dictionary objects are open and mutable for storing arbitrary data. To avoid collisions between components, the following key naming conventions SHOULD be honored.    Key names are Ordinal (case sensitive, culture insensitive) strings.    Most keys SHOULD be composed of a lower case prefix, a period, and a Pascal cased descriptor (e.g. owin.RequestMethod).    A number of common keys are listed later in this document. These keys use general prefixes such as server.* to indicate that this is data that may be provided by many different implementations. Implementers SHOULD favor using such shared keys rather than defining their own.    Keys that refer to a common technology group SHOULD be prefixed with a name that identifies that technology. E.g. ssl.  or websocket. .    Keys that expose functionality specific to a single implementation SHOULD use a prefix that clearly identifies that implementation. E.g.  iis.* ,  httplistener.* ,  webapi.* ,  mymiddleware.* .    Implementers SHOULD avoid defining keys that differ only subtly from existing keys (e.g. casing, spelling, etc.).    Implementers SHOULD include a technology specific version key that clearly identifies not only the version of the underlying component, but also the version of any OWIN specific wrapper of that component. E.g. mshttplistener.Version: .NET 4.0, OWIN wrapper 1.0.1. This is intended to help consumers cross reference documentation with implementations, facilitating both development and debugging.    The fully qualified name of a type MAY be used as the key, but only if it is reasonable to assume that there will only ever be one instance of this type per request. E.g.  System.Net.HttpListenerContext  is guaranteed to be unique per request, whereas  System.Security.Cryptography.X509Certificates.X509Certificate  identifies a specific type but it is ambiguous if the value represents the client certificate, the server certificate, or a certificate for some other purpose.", 
            "title": "3. Naming conventions"
        }, 
        {
            "location": "/CommonKeys/#446-value-conventions", 
            "text": "The type of each value SHOULD be clearly documented by the implementer.    Values MAY be of a type derived from the type specified in documentation, but the documentation SHOULD state under what conditions it is reasonable to expect such types to be available. Consumers may attempt to cast to more specific derived types (safely using is or as rather than an explicit cast), but SHOULD fall back to the documented base type wherever possible.    Null values or empty strings SHOULD be treated the same as if the key were not present. Every key SHOULD have at least one defined value, even if the value is the string \"true\".    Implementers SHOULD avoid populating keys associated with null values or empty strings, but SHOULD be tolerant of such values when retrieving data.    Implementers MUST NOT overload a single key with multiple types (other than derived types as discussed above). If there are multiple possible representations, use separate keys to clearly identify them.    Avoid using types that are likely to change signatures between versions.    Prefer base types (e.g. int, string, etc.) or common types in the .NET framework that have existed for multiple releases (e.g. Stream).    Values in the request Environment collection are assumed to be alive and accurate only for the lifetime of the request. Consumers SHOULD NOT retain or attempt to use values after a request has completed or failed. Where a value advertises a specific capability, that capability is only assumed to be available for that request instance and SHOULD be re-verified on future requests.    Global capabilities or data SHOULD be communicated as described in section 5 below.    Where any specific value cleanup is required (e.g. Dispose), such cleanup is the responsibility of the component that originally added the value. This should be taken care of as the stack unwinds after a request has completed or failed.", 
            "title": "4. Value conventions"
        }, 
        {
            "location": "/CommonKeys/#5-capabilities-announcement-and-detection", 
            "text": "It is important for applications to be able to determine if a specific feature is supported by the current server or middleware. The following pattern is recommended for announcing and detecting feature/extension support.    At startup the server SHOULD create a  server.Capabilities  object dictionary in the startup Properties dictionary.    This capabilities dictionary is for static capability details that do not change on a per-request basis.    The same instance of the capabilities dictionary SHOULD also be included in each request environment dictionary.    Each extension SHOULD add to the capabilities Dictionary a  featurename.Version  key with the associated string value of the latest version of that extension supported (e.g. 1.2).    If extensions have defined additional keys used to indicate details, the implementer SHOULD add to the capabilities Dicitonary a  featurename.Support  Dictionary containing the detailed featurename.FeatureDetail keys and their associated values.    Per-request feature keys and values should be included directly in the environment dictionary.", 
            "title": "5. Capabilities announcement and detection"
        }, 
        {
            "location": "/CommonKeys/#646-common-keys", 
            "text": "Keys and values listed here are those that are anticipated to be common across multiple implementations, but are not strictly required for basic operations.     Object Name  Type  Startup  Request  Description      ssl.ClientCertificate  X509Certificate   X  The client certificate provided during HTTPS SSL negotiation.    server.RemoteIpAddress  String   X  The IP Address of the remote client. E.g. 192.168.1.1 or ::1    server.RemotePort  String   X  The port of the remote client. e.g. 1234    server.LocalIpAddress  String   X  The local IP Address the request was received on. E.g. 127.0.0.1 or ::1    server.LocalPort  String   X  The port the request was received on. E.g. 80    server.IsLocal  Boolean   X  Was the request sent from the same machine? E.g. true or false.    host.TraceOutput  .log()  / TextWriter  X  X  A tracing output that may be provided by the host.    host.Addresses  List Object  X   A list of per-address server configuration. The following keys are defined with string values: scheme, host, port, path.    server.Capabilities  Dictionary Object  X  X  Global capabilities that do not change on a per-request basis. See Section 5 above.    server.OnSendingHeaders  function   X  Allows the caller to register an Action callback that fires as a last chance to modify response headers, status code, reason phrase, or protocol. The object parameter is an optional state object that will passed to the callback    websocket.*   X  X  See the WebSocket extension    sendfile.*   X  X  See the SendFile extension    opaque.*   X  X  See the Opaque extension    coap.*   X  X  See the CoAP extension or limerun/lime-coap    owind.*   X  X  See the OWIN-D extension", 
            "title": "6. Common keys"
        }, 
        {
            "location": "/Opaque/", 
            "text": "Opaque Stream Extension\n\n\nOWIN-JS Opaque Stream Extension\n\n\n\n\nLicense : \nCreative Commons Attribution 3.0 Unported License\n\n\n\n\nContents\n\n\n\n\n\n\nIntroduction\n\n\n\n\n\n\nDefinitions\n\n\n\n\n\n\nDetection\n\n\n\n\n\n\nUpgrade\n\n\n\n\n\n\nConsumption\n\n\n\n\n\n\nDelegate Signature\n\n\n\n\n\n\nUsage\n\n\n\n\n\n\n1. Introduction\n\n\nThis document outlines the recommended patterns for using opaque streams through the OWIN-JS interface. It depends on OWIN-JS version 1.0 or later, and uses the extension key mechanics as outlined in CommonKeys.\n\n\n2. Definitions\n\n\nOpaque Streams or Opaque Mode - Some servers allow a request to take direct ownership of the underlying connection after the initial HTTP handshake. This gives the application access to a bidirectional communication channel and the application is then responsible for employing its own protocol (e.g. WebSockets) to communicate with the client. Normally this involves sending a 101 response status code.\n\n\n3. Detection\n\n\nIn order for an application to use Opaque it MUST first detect support for the extension.\n\n\n3.1 Startup\n\n\nAt startup the server SHOULD specify in the Properties server.Capabilities dictionary if Opaque is supported (see the table below). If the application does not see support for Opaque but does see support for Opaque Streams, it MAY insert a middleware to add Opaque support.\n\n\n3.2 Per Request\n\n\nThe Opaque capable server or middleware inspects each request as it arrives to determine if it is Opaque compatible (e.g. verb, headers, etc.). If so, it marks the request with a specific environment key (see the table below).\n\n\n\n\n\n\n\n\nObject Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nopaque.Upgrade\n\n\nAn OpaqueUpgrade Action added by the server if the current request supports Opaque. See Delegate Signature\n\n\n\n\n\n\n\n\n4. Upgrade\n\n\nWhen an application sees a request that is marked as Opaque capable and decides to upgrade to Opaque, it indicates this to the server or middleware by invoking the provided OpaqueUpgrade Action with parameters and an OpaqueFunc callback. This Action MUST immediately set the response status code to 101 and validate any input parameters and request state. The application then completes the AppFunc Task and allows the request pipeline to unwind.\n\n\nWhen the pipeline has unwound to the Opaque server or middleware it SHOULD perform the requested upgrade. Once the upgrade is complete the request has left HTTP processing and transitioned to Opaque processing. The original Environment dictionary and its content are presumed invalid and a new one MUST be provided to the OpaqueFunc callback with the keys listed as required in the table below (see Consumption).\n\n\nIf the upgrade fails then the server or middleware SHOULD terminate the request. There is no guarantee that the OpaqueFunc provided by the application can or will be invoked in these scenarios, but the owin.CallCancelled CancellationToken MUST be signaled if the callback wont be.\n\n\nThe OpaqueUpgrade parameters dictionary MAY be null if there are no parameters to pass in. If not null, it MUST be mutable and use ordinal key comparison.\n\n\nIn addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the Opaque Upgrade to the parameters dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys.\n\n\n5. Consumption\n\n\nWhen the server or middleware invoke the OpaqueFunc it provides a new Opaque Environment dictionary (see Delegate Signature). The Opaque Environment dictionary has the same requirements as the OWIN request Environment dictionary, namely that it MUST be non-null, mutable, use ordinal key comparison, and MUST contain the keys and values where listed as required in the table below.\n\n\n\n\n\n\n\n\nRequired\n\n\nObject Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nYes\n\n\nopaque.Stream\n\n\nA duplex Stream for sending and receiving data.\n\n\n\n\n\n\nYes\n\n\nopaque.Version\n\n\nThe string value 1.0 indicating version 1.0 of this OWIN-JS Opaque extension.\n\n\n\n\n\n\nYes\n\n\nopaque.CallCancelled\n\n\nA CancellationToken provided by the server to signal that opaque streaming has been canceled/aborted.\n\n\n\n\n\n\n\n\nIn addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the Opaque context to the environment dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys\n\n\n6. Delegate Signature\n\n\nThe opaque stream body delegate signature is as follows:\n\n\nC#\n\n\nusing OpaqueUpgrade =\n    Action\n    \n\n        IDictionary\nstring, object\n, // Parameters\n        Func // OpaqueFunc callback\n        \n\n            IDictionary\nstring, object\n, // Opaque environment\n            Task // Complete\n        \n\n    \n;\n\nusing OpaqueFunc =\n    Func\n    \n\n        IDictionary\nstring, object\n, // Opaque Environment\n        Task // Complete\n    \n;\n\n\n\n7. Usage\n\n\nOnce the upgrade is complete the consumer operates their own protocol (e.g. WebSockets) over the given Stream. On completion (success or fail), the application MUST complete or fail the returned Task. The consumer SHOULD NOT close the given Stream, the provider (the server or middleware) owns these and is responsible for any cleanup on completion of the OpaqueFunc. The application SHOULD NOT continue to access the Stream once it completes the returned task.\n\n\nIf the \noapaque.CallCancelled\n CancellationToken is cancelled, the application SHOULD promptly terminate processing and complete the returned Task.", 
            "title": "Opaque"
        }, 
        {
            "location": "/Opaque/#opaque-stream-extension", 
            "text": "OWIN-JS Opaque Stream Extension   License :  Creative Commons Attribution 3.0 Unported License", 
            "title": "Opaque Stream Extension"
        }, 
        {
            "location": "/Opaque/#contents", 
            "text": "Introduction    Definitions    Detection    Upgrade    Consumption    Delegate Signature    Usage", 
            "title": "Contents"
        }, 
        {
            "location": "/Opaque/#1-introduction", 
            "text": "This document outlines the recommended patterns for using opaque streams through the OWIN-JS interface. It depends on OWIN-JS version 1.0 or later, and uses the extension key mechanics as outlined in CommonKeys.", 
            "title": "1. Introduction"
        }, 
        {
            "location": "/Opaque/#246-definitions", 
            "text": "Opaque Streams or Opaque Mode - Some servers allow a request to take direct ownership of the underlying connection after the initial HTTP handshake. This gives the application access to a bidirectional communication channel and the application is then responsible for employing its own protocol (e.g. WebSockets) to communicate with the client. Normally this involves sending a 101 response status code.", 
            "title": "2. Definitions"
        }, 
        {
            "location": "/Opaque/#346-detection", 
            "text": "In order for an application to use Opaque it MUST first detect support for the extension.  3.1 Startup  At startup the server SHOULD specify in the Properties server.Capabilities dictionary if Opaque is supported (see the table below). If the application does not see support for Opaque but does see support for Opaque Streams, it MAY insert a middleware to add Opaque support.  3.2 Per Request  The Opaque capable server or middleware inspects each request as it arrives to determine if it is Opaque compatible (e.g. verb, headers, etc.). If so, it marks the request with a specific environment key (see the table below).     Object Name  Description      opaque.Upgrade  An OpaqueUpgrade Action added by the server if the current request supports Opaque. See Delegate Signature", 
            "title": "3. Detection"
        }, 
        {
            "location": "/Opaque/#446-upgrade", 
            "text": "When an application sees a request that is marked as Opaque capable and decides to upgrade to Opaque, it indicates this to the server or middleware by invoking the provided OpaqueUpgrade Action with parameters and an OpaqueFunc callback. This Action MUST immediately set the response status code to 101 and validate any input parameters and request state. The application then completes the AppFunc Task and allows the request pipeline to unwind.  When the pipeline has unwound to the Opaque server or middleware it SHOULD perform the requested upgrade. Once the upgrade is complete the request has left HTTP processing and transitioned to Opaque processing. The original Environment dictionary and its content are presumed invalid and a new one MUST be provided to the OpaqueFunc callback with the keys listed as required in the table below (see Consumption).  If the upgrade fails then the server or middleware SHOULD terminate the request. There is no guarantee that the OpaqueFunc provided by the application can or will be invoked in these scenarios, but the owin.CallCancelled CancellationToken MUST be signaled if the callback wont be.  The OpaqueUpgrade parameters dictionary MAY be null if there are no parameters to pass in. If not null, it MUST be mutable and use ordinal key comparison.  In addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the Opaque Upgrade to the parameters dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys.", 
            "title": "4. Upgrade"
        }, 
        {
            "location": "/Opaque/#546-consumption", 
            "text": "When the server or middleware invoke the OpaqueFunc it provides a new Opaque Environment dictionary (see Delegate Signature). The Opaque Environment dictionary has the same requirements as the OWIN request Environment dictionary, namely that it MUST be non-null, mutable, use ordinal key comparison, and MUST contain the keys and values where listed as required in the table below.     Required  Object Name  Description      Yes  opaque.Stream  A duplex Stream for sending and receiving data.    Yes  opaque.Version  The string value 1.0 indicating version 1.0 of this OWIN-JS Opaque extension.    Yes  opaque.CallCancelled  A CancellationToken provided by the server to signal that opaque streaming has been canceled/aborted.     In addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the Opaque context to the environment dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys", 
            "title": "5. Consumption"
        }, 
        {
            "location": "/Opaque/#646-delegate-signature", 
            "text": "The opaque stream body delegate signature is as follows:  C#  using OpaqueUpgrade =\n    Action\n     \n        IDictionary string, object , // Parameters\n        Func // OpaqueFunc callback\n         \n            IDictionary string, object , // Opaque environment\n            Task // Complete\n         \n     ;\n\nusing OpaqueFunc =\n    Func\n     \n        IDictionary string, object , // Opaque Environment\n        Task // Complete\n     ;", 
            "title": "6. Delegate Signature"
        }, 
        {
            "location": "/Opaque/#746-usage", 
            "text": "Once the upgrade is complete the consumer operates their own protocol (e.g. WebSockets) over the given Stream. On completion (success or fail), the application MUST complete or fail the returned Task. The consumer SHOULD NOT close the given Stream, the provider (the server or middleware) owns these and is responsible for any cleanup on completion of the OpaqueFunc. The application SHOULD NOT continue to access the Stream once it completes the returned task.  If the  oapaque.CallCancelled  CancellationToken is cancelled, the application SHOULD promptly terminate processing and complete the returned Task.", 
            "title": "7. Usage"
        }, 
        {
            "location": "/Websocket/", 
            "text": "WebSocket Extension\n\n\nOWIN-JS WebSocket Extension\n\n\n\n\nLicense : \nCreative Commons Attribution 3.0 Unported License\n\n\n\n\nContents\n\n\n\n\n\n\nIntroduction\n\n\n\n\n\n\nDefinitions\n\n\n\n\n\n\nDetection\n\n\n\n\n\n\nAccept\n\n\n\n\n\n\nConsumption\n\n\n\n\n\n\nDelegate Signature\n\n\n\n\n\n\nUsage\n\n\n\n\n\n\n1. Introduction\n\n\nThis document outlines the recommended patterns for using WebSockets through the OWIN-JS interface. It depends on OWIN-JS v1.0 or later, the OWIN-JS opaque streams extension, and uses the extension key mechanics as outlined in CommonKeys.\n\n\n2. Definitions\n\n\nWebSocket - Defined in RFC 6455, a web socket is a bidirectional, framed communication channel that uses HTTP for its initial handshake.\n\n\nOpaque Stream - Some servers allow a request to take direct ownership of the underlying connection after the initial HTTP handshake. This gives the application access to a bidirectional opaque stream and the application is then responsible for employing its own protocol (e.g. WebSockets) to communicate with the client.\n\n\n3. Detection\n\n\nIn order for an application to use WebSockets it MUST first detect support for the extension.\n\n\n3.1 Startup\n\n\nAt startup the server SHOULD specify in the Properties server.Capabilities dictionary if WebSockets is supported (see the table below). If the application does not see support for WebSockets but does see support for Opaque Streams, it MAY insert a middleware to add WebSocket support.\n\n\n\n\n\n\n\n\nObject Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwebsocket.Version\n\n\nThe string value 1.0 indicating version 1.0 of the OWIN WebSocket extension\n\n\n\n\n\n\n\n\n3.2 Per Request\n\n\nThe WebSocket capable server or middleware inspects each request as it arrives to determine if it is WebSocket compatible (e.g. verb, headers, etc.). If so, it marks the request with a specific environment key (see the table below).\n\n\n\n\n\n\n\n\nObject Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwebsocket.Accept\n\n\nA WebSocketAccept Action added by the server if the current request supports WebSockets. See Delegate Signature\n\n\n\n\n\n\n\n\n4. Accept\n\n\nWhen an application sees a request that is marked as WebSocket capable and decides to accept to a WebSocket, it indicates this to the server or middleware by invoking the provided WebSocketAccept Action with parameters and a WebSocketFunc callback. This Action MUST immediately set the response status code to 101 and validate any input parameters and request state. The application then completes the AppFunc Task and allows the request pipeline to unwind.\n\n\nBefore invoking the WebSocketAccept Action the application MAY set the Sec-WebSocket-Protocol response header OR specify the subprotocol property in the parameters dictionary (see the table below), according to RFC 6455 Section 4.2.2 Step 5.5.\n\n\nWhen the pipeline has unwound to the WebSocket server or middleware it SHOULD perform the requested accept. The WebSocket server or middleware MUST provide the necessary WebSocket response headers when performing the accept. Once the accept is complete the request has left HTTP processing and transitioned to WebSocket processing. The original Environment dictionary and its content are presumed invalid and a new one MUST be provided to the WebSocketFunc callback with the keys listed as required in the table below (see Consumption).\n\n\nIf the accept fails then the server or middleware SHOULD terminate the request. There is no guarantee that the WebSocketFunc provided by the application can or will be invoked in these scenarios, but the owin.CallCancelled CancellationToken MUST be signaled if the callback wont be.\n\n\nThe WebSocketAccept parameters dictionary MAY be null if there are no parameters to pass in. If not null, it MUST be mutable and use ordinal key comparison.\n\n\n\n\n\n\n\n\nObject Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwebsocket.SubProtocol\n\n\nThe negotiated protocol according to RFC 6455 Section 4.2.2 Step 5.5\n\n\n\n\n\n\n\n\nIn addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the WebSocket Accept to the parameters dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys.html.\n\n\n5. Consumption\n\n\nWhen the server or middleware invoke the WebSocketFunc it provides a new WebSocket Environment dictionary (see Delegate Signature). The WebSocket Environment dictionary has the same requirements as the OWIN request Environment dictionary, namely that it MUST be non-null, mutable, use ordinal key comparison, and MUST contain the keys and values where listed as required in the table below.\n\n\n\n\n\n\n\n\nRequired\n\n\nObject Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nYes\n\n\nwebsocket.SendAsync\n\n\nA Func used to send data. See Delegate Signature.\n\n\n\n\n\n\nYes\n\n\nwebsocket.ReceiveAsync\n\n\nA Func used to receive data. See Delegate Signature..\n\n\n\n\n\n\nYes\n\n\nwebsocket.CloseAsync\n\n\nA Func used to close the output channel. See Delegate Signature.\n\n\n\n\n\n\nYes\n\n\nwebsocket.Version\n\n\nThe string value 1.0 indicating version 1.0 of this OWIN WebSockets extension.\n\n\n\n\n\n\nYes\n\n\nwebsocket.CallCancelled\n\n\nA CancellationToken provided by the server to signal that the WebSocket has been canceled/aborted.\n\n\n\n\n\n\nNo\n\n\nwebsocket.ClientCloseStatus\n\n\nAn optional int that may be set by the server or middleware when a close frame is received.\n\n\n\n\n\n\nNo\n\n\nwebsocket.ClientCloseDescription\n\n\nAn optional string that may be set by the server or middleware when a close frame is received.\n\n\n\n\n\n\n\n\nIn addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the WebSocket context to the environment dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys.html.\n\n\n6. Delegate Signature\n\n\nThe WebSocket signatures are follows:\n\n\nC#\n\n\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nnamespace Owin.WebSockets\n{\nusing WebSocketAccept =\n    Action\n    \n\n        IDictionary\nstring, object\n, // WebSocket Accept parameters\n        Func // WebSocketFunc callback\n        \n\n            IDictionary\nstring, object\n, // WebSocket environment\n            Task // Complete\n        \n\n    \n;\n\nusing WebSocketFunc =\n    Func\n    \n\n        IDictionary\nstring, object\n, // WebSocket Environment\n        Task // Complete\n    \n;\n\nusing WebSocketSendAsync =\n    Func\n    \n\n        ArraySegment\nbyte\n /* data */,\n        int /* messageType */,\n        bool /* endOfMessage */,\n        CancellationToken /* cancel */,\n        Task\n    \n;\n\nusing WebSocketReceiveAsync =\n    Func\n    \n\n        ArraySegment\nbyte\n /* data */,\n        CancellationToken /* cancel */,\n        Task\n        \n\n            Tuple\n            \n\n                int /* messageType */,\n                bool /* endOfMessage */,\n                int /* count */\n            \n\n        \n\n    \n;\n\nusing WebSocketReceiveTuple =\n    Tuple\n    \n\n        int /* messageType */,\n        bool /* endOfMessage */,\n        int /* count */\n    \n;\n\nusing WebSocketCloseAsync =\n    Func\n    \n\n        int /* closeStatus */,\n        string /* closeDescription */,\n        CancellationToken /* cancel */,\n        Task\n    \n;\n}\n\n\n\n7. Usage\n\n\n7.1 WebSocketAccept\n\n\nProvided by the server in the original environment dictionary for a WebSocket compatible request. This is invoked by the application to request the upgrade to WebSockets. The parameters dictionary may be null, but the WebSocketFunc callback MUST NOT be null. Invoking this will cause the response status code to be set to 101.\n\n\n7.2 WebSocketFunc\n\n\nThis is the WebSocket application entry point. The server provides an Dictionary containing request information and the Send, Receive, and Close Funcs. On completion (success or fail), the application MUST complete or fail the returned Task or throw a synchronous exception.\n\n\n7.3 WebSocketSendAsync\n\n\nThe application uses the WebSocketSendAsync Func to send data to the client. The application does not have direct control over frame boundaries, but it does control message boundaries. The values of messageType MUST match the opcodes defined in the RFC; E.g. 0x1 = Text, 0x2 = Binary, and 0x8 = Close. If SendAsync is used to send a close frame, the ArraySegment must either refer to a null or empty segment, or must contain the close status code and message as defined in RFC 6455 section 5.5.1. Ping and Pong control frames (0x9, 0xA) MAY be sent, but the underlying server or middleware MUST silently discard them if it does not permit them.\n\n\n7.4 WebSocketReceiveAsync\n\n\nReceiveAsync will return the current message type, if the full message was consumed, and the count of data copied to the given buffer. The values of messageType MUST match the opcodes defined in the RFC; 0x1 = Text, 0x2 = Binary, and 0x8 = Close. The server or middleware MUST perform any necessary un-masking of the data before returning it. If a close frame is received the count will be 0 and any close status or description will be set in the websocket environment dictionary under \nwebsocket.ClientCloseStatus\n and \nwebsocket.ClientCloseDescription\n if such values were sent by the client. Close data MUST NOT be copied to the users buffer. The server or middleware MUST NOT deliver Ping and Pong control frames (0x9, 0xA) to the application, they MUST be handled internally.\n\n\n7.5 WebSocketCloseAsync\n\n\nApplications SHOULD follow the RFC guidelines regarding CloseAsync (section 5.5.1). The application SHOULD invoke CloseAsync when it is done sending outgoing data. The application MUST NOT attempt to send additional data after sending a close frame. The application MUST NOT attempt any further receives after a close frame is received. The application MAY abortively terminate the connection at any time by completing the WebSocketFunc return Task, optionally with an exception. The application SHOULD NOT invoke any of the delegates after it completes the returned task.", 
            "title": "Websocket"
        }, 
        {
            "location": "/Websocket/#websocket-extension", 
            "text": "OWIN-JS WebSocket Extension   License :  Creative Commons Attribution 3.0 Unported License", 
            "title": "WebSocket Extension"
        }, 
        {
            "location": "/Websocket/#contents", 
            "text": "Introduction    Definitions    Detection    Accept    Consumption    Delegate Signature    Usage", 
            "title": "Contents"
        }, 
        {
            "location": "/Websocket/#1-introduction", 
            "text": "This document outlines the recommended patterns for using WebSockets through the OWIN-JS interface. It depends on OWIN-JS v1.0 or later, the OWIN-JS opaque streams extension, and uses the extension key mechanics as outlined in CommonKeys.", 
            "title": "1. Introduction"
        }, 
        {
            "location": "/Websocket/#246-definitions", 
            "text": "WebSocket - Defined in RFC 6455, a web socket is a bidirectional, framed communication channel that uses HTTP for its initial handshake.  Opaque Stream - Some servers allow a request to take direct ownership of the underlying connection after the initial HTTP handshake. This gives the application access to a bidirectional opaque stream and the application is then responsible for employing its own protocol (e.g. WebSockets) to communicate with the client.", 
            "title": "2. Definitions"
        }, 
        {
            "location": "/Websocket/#346-detection", 
            "text": "In order for an application to use WebSockets it MUST first detect support for the extension.  3.1 Startup  At startup the server SHOULD specify in the Properties server.Capabilities dictionary if WebSockets is supported (see the table below). If the application does not see support for WebSockets but does see support for Opaque Streams, it MAY insert a middleware to add WebSocket support.     Object Name  Description      websocket.Version  The string value 1.0 indicating version 1.0 of the OWIN WebSocket extension     3.2 Per Request  The WebSocket capable server or middleware inspects each request as it arrives to determine if it is WebSocket compatible (e.g. verb, headers, etc.). If so, it marks the request with a specific environment key (see the table below).     Object Name  Description      websocket.Accept  A WebSocketAccept Action added by the server if the current request supports WebSockets. See Delegate Signature", 
            "title": "3. Detection"
        }, 
        {
            "location": "/Websocket/#446-accept", 
            "text": "When an application sees a request that is marked as WebSocket capable and decides to accept to a WebSocket, it indicates this to the server or middleware by invoking the provided WebSocketAccept Action with parameters and a WebSocketFunc callback. This Action MUST immediately set the response status code to 101 and validate any input parameters and request state. The application then completes the AppFunc Task and allows the request pipeline to unwind.  Before invoking the WebSocketAccept Action the application MAY set the Sec-WebSocket-Protocol response header OR specify the subprotocol property in the parameters dictionary (see the table below), according to RFC 6455 Section 4.2.2 Step 5.5.  When the pipeline has unwound to the WebSocket server or middleware it SHOULD perform the requested accept. The WebSocket server or middleware MUST provide the necessary WebSocket response headers when performing the accept. Once the accept is complete the request has left HTTP processing and transitioned to WebSocket processing. The original Environment dictionary and its content are presumed invalid and a new one MUST be provided to the WebSocketFunc callback with the keys listed as required in the table below (see Consumption).  If the accept fails then the server or middleware SHOULD terminate the request. There is no guarantee that the WebSocketFunc provided by the application can or will be invoked in these scenarios, but the owin.CallCancelled CancellationToken MUST be signaled if the callback wont be.  The WebSocketAccept parameters dictionary MAY be null if there are no parameters to pass in. If not null, it MUST be mutable and use ordinal key comparison.     Object Name  Description      websocket.SubProtocol  The negotiated protocol according to RFC 6455 Section 4.2.2 Step 5.5     In addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the WebSocket Accept to the parameters dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys.html.", 
            "title": "4. Accept"
        }, 
        {
            "location": "/Websocket/#546-consumption", 
            "text": "When the server or middleware invoke the WebSocketFunc it provides a new WebSocket Environment dictionary (see Delegate Signature). The WebSocket Environment dictionary has the same requirements as the OWIN request Environment dictionary, namely that it MUST be non-null, mutable, use ordinal key comparison, and MUST contain the keys and values where listed as required in the table below.     Required  Object Name  Description      Yes  websocket.SendAsync  A Func used to send data. See Delegate Signature.    Yes  websocket.ReceiveAsync  A Func used to receive data. See Delegate Signature..    Yes  websocket.CloseAsync  A Func used to close the output channel. See Delegate Signature.    Yes  websocket.Version  The string value 1.0 indicating version 1.0 of this OWIN WebSockets extension.    Yes  websocket.CallCancelled  A CancellationToken provided by the server to signal that the WebSocket has been canceled/aborted.    No  websocket.ClientCloseStatus  An optional int that may be set by the server or middleware when a close frame is received.    No  websocket.ClientCloseDescription  An optional string that may be set by the server or middleware when a close frame is received.     In addition to these keys the host, server, middleware, application, etc. may add arbitrary data associated with the WebSocket context to the environment dictionary. Guidelines for additional keys and a list of commonly defined keys can be found in CommonKeys.html.", 
            "title": "5. Consumption"
        }, 
        {
            "location": "/Websocket/#646-delegate-signature", 
            "text": "The WebSocket signatures are follows:  C#  using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nnamespace Owin.WebSockets\n{\nusing WebSocketAccept =\n    Action\n     \n        IDictionary string, object , // WebSocket Accept parameters\n        Func // WebSocketFunc callback\n         \n            IDictionary string, object , // WebSocket environment\n            Task // Complete\n         \n     ;\n\nusing WebSocketFunc =\n    Func\n     \n        IDictionary string, object , // WebSocket Environment\n        Task // Complete\n     ;\n\nusing WebSocketSendAsync =\n    Func\n     \n        ArraySegment byte  /* data */,\n        int /* messageType */,\n        bool /* endOfMessage */,\n        CancellationToken /* cancel */,\n        Task\n     ;\n\nusing WebSocketReceiveAsync =\n    Func\n     \n        ArraySegment byte  /* data */,\n        CancellationToken /* cancel */,\n        Task\n         \n            Tuple\n             \n                int /* messageType */,\n                bool /* endOfMessage */,\n                int /* count */\n             \n         \n     ;\n\nusing WebSocketReceiveTuple =\n    Tuple\n     \n        int /* messageType */,\n        bool /* endOfMessage */,\n        int /* count */\n     ;\n\nusing WebSocketCloseAsync =\n    Func\n     \n        int /* closeStatus */,\n        string /* closeDescription */,\n        CancellationToken /* cancel */,\n        Task\n     ;\n}", 
            "title": "6. Delegate Signature"
        }, 
        {
            "location": "/Websocket/#746-usage", 
            "text": "7.1 WebSocketAccept  Provided by the server in the original environment dictionary for a WebSocket compatible request. This is invoked by the application to request the upgrade to WebSockets. The parameters dictionary may be null, but the WebSocketFunc callback MUST NOT be null. Invoking this will cause the response status code to be set to 101.  7.2 WebSocketFunc  This is the WebSocket application entry point. The server provides an Dictionary containing request information and the Send, Receive, and Close Funcs. On completion (success or fail), the application MUST complete or fail the returned Task or throw a synchronous exception.  7.3 WebSocketSendAsync  The application uses the WebSocketSendAsync Func to send data to the client. The application does not have direct control over frame boundaries, but it does control message boundaries. The values of messageType MUST match the opcodes defined in the RFC; E.g. 0x1 = Text, 0x2 = Binary, and 0x8 = Close. If SendAsync is used to send a close frame, the ArraySegment must either refer to a null or empty segment, or must contain the close status code and message as defined in RFC 6455 section 5.5.1. Ping and Pong control frames (0x9, 0xA) MAY be sent, but the underlying server or middleware MUST silently discard them if it does not permit them.  7.4 WebSocketReceiveAsync  ReceiveAsync will return the current message type, if the full message was consumed, and the count of data copied to the given buffer. The values of messageType MUST match the opcodes defined in the RFC; 0x1 = Text, 0x2 = Binary, and 0x8 = Close. The server or middleware MUST perform any necessary un-masking of the data before returning it. If a close frame is received the count will be 0 and any close status or description will be set in the websocket environment dictionary under  websocket.ClientCloseStatus  and  websocket.ClientCloseDescription  if such values were sent by the client. Close data MUST NOT be copied to the users buffer. The server or middleware MUST NOT deliver Ping and Pong control frames (0x9, 0xA) to the application, they MUST be handled internally.  7.5 WebSocketCloseAsync  Applications SHOULD follow the RFC guidelines regarding CloseAsync (section 5.5.1). The application SHOULD invoke CloseAsync when it is done sending outgoing data. The application MUST NOT attempt to send additional data after sending a close frame. The application MUST NOT attempt any further receives after a close frame is received. The application MAY abortively terminate the connection at any time by completing the WebSocketFunc return Task, optionally with an exception. The application SHOULD NOT invoke any of the delegates after it completes the returned task.", 
            "title": "7. Usage"
        }, 
        {
            "location": "/nodekit/", 
            "text": "nodekit.io Keys\n\n\n\n\nAuthor : OWIN-JS working group\n\n\nCopyright : OWIN-JS contributors\n\n\nLicense : \nCreative Commons Attribution 3.0 Unported License\n\n\n\n\nContents\n\n\n\n\n\n\nOverview\n\n\n\n\n\n\nKey usage guidelines\n\n\n\n\n\n\nNaming conventions\n\n\n\n\n\n\nValue conventions\n\n\n\n\n\n\nCapabilities announcement and detection\n\n\n\n\n\n\nnodeAppKit keys\n\n\n\n\n\n\n1. Overview\n\n\nThis document contains additional keys used by the nodekit.io reference application.\n\n\n2. Key usage guidelines\n\n\nThe Dictionary object can be used to extend the OWIN-JS interface with additional functionality.\n\n\n\n\n\n\nAll keys MUST be compared using Ordinal.\n\n\n\n\n\n\nAll keys not defined in the OWIN-JS standard are considered extension keys and are strictly optional.\n\n\n\n\n\n\nImplementers SHOULD clearly document what keys their component will populate, under what conditions, and the types and semantics of the associated values.\n\n\n\n\n\n\n3. Naming conventions\n\n\nThe Dictionary objects are open and mutable for storing arbitrary data. To avoid collisions between components, the following key naming conventions SHOULD be honored.\n\n\n\n\nKey names are Ordinal (case sensitive, culture insensitive) strings.\n\n\n\n\n4. Value conventions\n\n\nThe type of each value SHOULD be clearly documented by the implementer.\n\n\n\n\n\n\nValues MAY be of a type derived from the type specified in documentation, but the documentation SHOULD state under what conditions it is reasonable to expect such types to be available. Consumers may attempt to cast to more specific derived types (safely using is or as rather than an explicit cast), but SHOULD fall back to the documented base type wherever possible.\n\n\n\n\n\n\nNull values or empty strings SHOULD be treated the same as if the key were not present. Every key SHOULD have at least one defined value, even if the value is the string \"true\".\n\n\n\n\n\n\nImplementers SHOULD avoid populating keys associated with null values or empty strings, but SHOULD be tolerant of such values when retrieving data.\n\n\n\n\n\n\nImplementers MUST NOT overload a single key with multiple types (other than derived types as discussed above). If there are multiple possible representations, use separate keys to clearly identify them.\n\n\n\n\n\n\nAvoid using types that are likely to change signatures between versions.\n\n\n\n\n\n\nPrefer base types (e.g. int, string, etc.) or common types in the .NET framework that have existed for multiple releases (e.g. Stream).\n\n\n\n\n\n\nValues in the request Environment collection are assumed to be alive and accurate only for the lifetime of the request. Consumers SHOULD NOT retain or attempt to use values after a request has completed or failed. Where a value advertises a specific capability, that capability is only assumed to be available for that request instance and SHOULD be re-verified on future requests.\n\n\n\n\n\n\nGlobal capabilities or data SHOULD be communicated as described in section 5 below.\n\n\n\n\n\n\nWhere any specific value cleanup is required (e.g. Dispose), such cleanup is the responsibility of the component that originally added the value. This should be taken care of as the stack unwinds after a request has completed or failed.\n\n\n5. Capabilities announcement and detection\n\n\nIt is important for applications to be able to determine if a specific feature is supported by the current server or middleware. The following pattern is recommended for announcing and detecting feature/extension support.\n\n\n\n\n\n\nAt startup the server SHOULD create a \nserver.Capabilities\n object dictionary in the startup Properties dictionary.\n\n\n\n\n\n\nThis capabilities dictionary is for static capability details that do not change on a per-request basis.\n\n\n\n\n\n\nThe same instance of the capabilities dictionary SHOULD also be included in each request environment dictionary.\n\n\n\n\n\n\nEach extension SHOULD add to the capabilities Dictionary a \nnodeAppKit.Version\n key with the associated string value of the latest version of that extension supported (e.g. 1.2).\n\n\n\n\n\n\nIf extensions have defined additional keys used to indicate details, the implementer SHOULD add to the capabilities Dicitonary a \nnodeAppKit.Support\n Dictionary containing the detailed \nnodeAppKit.FeatureDetail\n keys and their associated values.\n\n\n\n\n\n\nPer-request feature keys and values should be included directly in the environment dictionary.\n\n\n\n\n\n\n6. nodekit keys\n\n\nKeys and values listed here are those that are anticipated to be common across multiple implementations, but are not strictly required for basic operations.\n\n\n\n\n\n\n\n\nObject Name\n\n\nType\n\n\nStartup\n\n\nRequest\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nio.nodekit.Version\n\n\nString\n\n\nX\n\n\nX\n\n\n\"1.0\"", 
            "title": "io.nodekit"
        }, 
        {
            "location": "/nodekit/#nodekitio-keys", 
            "text": "Author : OWIN-JS working group  Copyright : OWIN-JS contributors  License :  Creative Commons Attribution 3.0 Unported License", 
            "title": "nodekit.io Keys"
        }, 
        {
            "location": "/nodekit/#contents", 
            "text": "Overview    Key usage guidelines    Naming conventions    Value conventions    Capabilities announcement and detection    nodeAppKit keys", 
            "title": "Contents"
        }, 
        {
            "location": "/nodekit/#1-overview", 
            "text": "This document contains additional keys used by the nodekit.io reference application.", 
            "title": "1. Overview"
        }, 
        {
            "location": "/nodekit/#246-key-usage-guidelines", 
            "text": "The Dictionary object can be used to extend the OWIN-JS interface with additional functionality.    All keys MUST be compared using Ordinal.    All keys not defined in the OWIN-JS standard are considered extension keys and are strictly optional.    Implementers SHOULD clearly document what keys their component will populate, under what conditions, and the types and semantics of the associated values.", 
            "title": "2. Key usage guidelines"
        }, 
        {
            "location": "/nodekit/#346-naming-conventions", 
            "text": "The Dictionary objects are open and mutable for storing arbitrary data. To avoid collisions between components, the following key naming conventions SHOULD be honored.   Key names are Ordinal (case sensitive, culture insensitive) strings.", 
            "title": "3. Naming conventions"
        }, 
        {
            "location": "/nodekit/#446-value-conventions", 
            "text": "The type of each value SHOULD be clearly documented by the implementer.    Values MAY be of a type derived from the type specified in documentation, but the documentation SHOULD state under what conditions it is reasonable to expect such types to be available. Consumers may attempt to cast to more specific derived types (safely using is or as rather than an explicit cast), but SHOULD fall back to the documented base type wherever possible.    Null values or empty strings SHOULD be treated the same as if the key were not present. Every key SHOULD have at least one defined value, even if the value is the string \"true\".    Implementers SHOULD avoid populating keys associated with null values or empty strings, but SHOULD be tolerant of such values when retrieving data.    Implementers MUST NOT overload a single key with multiple types (other than derived types as discussed above). If there are multiple possible representations, use separate keys to clearly identify them.    Avoid using types that are likely to change signatures between versions.    Prefer base types (e.g. int, string, etc.) or common types in the .NET framework that have existed for multiple releases (e.g. Stream).    Values in the request Environment collection are assumed to be alive and accurate only for the lifetime of the request. Consumers SHOULD NOT retain or attempt to use values after a request has completed or failed. Where a value advertises a specific capability, that capability is only assumed to be available for that request instance and SHOULD be re-verified on future requests.    Global capabilities or data SHOULD be communicated as described in section 5 below.    Where any specific value cleanup is required (e.g. Dispose), such cleanup is the responsibility of the component that originally added the value. This should be taken care of as the stack unwinds after a request has completed or failed.", 
            "title": "4. Value conventions"
        }, 
        {
            "location": "/nodekit/#5-capabilities-announcement-and-detection", 
            "text": "It is important for applications to be able to determine if a specific feature is supported by the current server or middleware. The following pattern is recommended for announcing and detecting feature/extension support.    At startup the server SHOULD create a  server.Capabilities  object dictionary in the startup Properties dictionary.    This capabilities dictionary is for static capability details that do not change on a per-request basis.    The same instance of the capabilities dictionary SHOULD also be included in each request environment dictionary.    Each extension SHOULD add to the capabilities Dictionary a  nodeAppKit.Version  key with the associated string value of the latest version of that extension supported (e.g. 1.2).    If extensions have defined additional keys used to indicate details, the implementer SHOULD add to the capabilities Dicitonary a  nodeAppKit.Support  Dictionary containing the detailed  nodeAppKit.FeatureDetail  keys and their associated values.    Per-request feature keys and values should be included directly in the environment dictionary.", 
            "title": "5. Capabilities announcement and detection"
        }, 
        {
            "location": "/nodekit/#646-nodekit-keys", 
            "text": "Keys and values listed here are those that are anticipated to be common across multiple implementations, but are not strictly required for basic operations.     Object Name  Type  Startup  Request  Description      io.nodekit.Version  String  X  X  \"1.0\"", 
            "title": "6. nodekit keys"
        }
    ]
}